<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>pymata_rh.pymata_rh API documentation</title>
<meta name="description" content="Copyright (c) 2020 Alan Yorinks All rights reserved â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pymata_rh.pymata_rh</code></h1>
</header>
<section id="section-intro">
<p>Copyright (c) 2020 Alan Yorinks All rights reserved.</p>
<p>This program is free software; you can redistribute it and/or
modify it under the terms of the GNU AFFERO GENERAL PUBLIC LICENSE
Version 3 as published by the Free Software Foundation; either
or (at your option) any later version.
This library is distributed in the hope that it will be useful,f
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU
General Public License for more details.</p>
<p>You should have received a copy of the GNU AFFERO GENERAL PUBLIC LICENSE
along with this library; if not, write to the Free Software
Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
02110-1301
USA</p>
<p>This class exposes and implements the pymata_rh API for the
RoboHAT MM1.</p>
<p>The following table maps RoboHAT MM1 pin names
to digital pin numbers and analog input pin numbers.</p>
<p>Note: The Button pin mode is fixed to digital input.
All other digital pins may be configured as input, output or PWM</p>
<table>
<thead>
<tr>
<th>Pin</th>
<th>Digital / Analog Pin #</th>
</tr>
</thead>
<tbody>
<tr>
<td>Servo1</td>
<td>2</td>
</tr>
<tr>
<td>Servo2</td>
<td>3</td>
</tr>
<tr>
<td>Servo3</td>
<td>4</td>
</tr>
<tr>
<td>Servo4</td>
<td>5</td>
</tr>
<tr>
<td>Servo5</td>
<td>6</td>
</tr>
<tr>
<td>Servo6</td>
<td>7</td>
</tr>
<tr>
<td>Servo7</td>
<td>8</td>
</tr>
<tr>
<td>Servo8</td>
<td>9</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>Button</td>
<td>10</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>NeoPixel</td>
<td>11</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>LED</td>
<td>13</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>RCC1</td>
<td>14 / A0</td>
</tr>
<tr>
<td>RCC2</td>
<td>15 / A1</td>
</tr>
<tr>
<td>RCC3</td>
<td>16 / A2</td>
</tr>
<tr>
<td>RCC4</td>
<td>17 / A3</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>GPS RX</td>
<td>39</td>
</tr>
<tr>
<td>GPS TX</td>
<td>40</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>Grove 1</td>
<td>41 / A27</td>
</tr>
<tr>
<td>Grove 2</td>
<td>42 / A28</td>
</tr>
</tbody>
</table>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
 Copyright (c) 2020 Alan Yorinks All rights reserved.

 This program is free software; you can redistribute it and/or
 modify it under the terms of the GNU AFFERO GENERAL PUBLIC LICENSE
 Version 3 as published by the Free Software Foundation; either
 or (at your option) any later version.
 This library is distributed in the hope that it will be useful,f
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 General Public License for more details.

 You should have received a copy of the GNU AFFERO GENERAL PUBLIC LICENSE
 along with this library; if not, write to the Free Software
 Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

 This class exposes and implements the pymata_rh API for the
 RoboHAT MM1.

 The following table maps RoboHAT MM1 pin names
 to digital pin numbers and analog input pin numbers.

 Note: The Button pin mode is fixed to digital input.
       All other digital pins may be configured as input, output or PWM


| Pin      | Digital / Analog Pin # |
| -------- | ---------------------- |
| Servo1   | 2                      |
| Servo2   | 3                      |
| Servo3   | 4                      |
| Servo4   | 5                      |
| Servo5   | 6                      |
| Servo6   | 7                      |
| Servo7   | 8                      |
| Servo8   | 9                      |
|          |                        |
| Button   | 10                     |
|          |                        |
| NeoPixel | 11                     |
|          |                        |
| LED      | 13                     |
|          |                        |
| RCC1     | 14 / A0                |
| RCC2     | 15 / A1                |
| RCC3     | 16 / A2                |
| RCC4     | 17 / A3                |
|          |                        |
| GPS RX   | 39                     |
| GPS TX   | 40                     |
|          |                        |
| Grove 1  | 41 / A27               |
| Grove 2  | 42 / A28               |
&#34;&#34;&#34;

from collections import deque
import datetime
import logging
# noinspection PyPackageRequirements
import serial
# noinspection PyPackageRequirements
from serial.tools import list_ports
# noinspection PyPackageRequirementscd,PyPackageRequirements
from serial.serialutil import SerialException
import socket
import sys
import threading
import time

from pymata_rh.pin_data import PinData
from pymata_rh.private_constants import PrivateConstants
from pymata_rh.mpu_9250.mpu_9250 import MPU9250
import pymata_rh.mpu_9250.mpu_9250_constants as mpu_constants
from pymata_rh.ina_219.ina_219 import INA219


# noinspection PyPep8
class PymataRh(threading.Thread):
    &#34;&#34;&#34;
    This class exposes and implements the PymataExpress Non-asyncio API.
    It uses threading to accommodate concurrency.
    It includes the public API methods as well as
    a set of private methods.

    &#34;&#34;&#34;

    # noinspection PyPep8,PyPep8,PyPep8
    def __init__(self, com_port=None, baud_rate=115200,
                 arduino_instance_id=1, arduino_wait=4,
                 sleep_tune=0.000001,
                 shutdown_on_exception=True, ip_address=None,
                 ip_port=None):
        &#34;&#34;&#34;
        If you are using the Firmata Express Arduino sketch,
        and have a single Arduino connected to your computer,
        then you may accept all the default values.

        If you are using some other Firmata sketch, then
        you must specify both the com_port and baudrate for
        as serial connection, or ip_address and ip_port if
        using StandardFirmataWifi.

        :param com_port: e.g. COM3 or /dev/ttyACM0.

        :param baud_rate: Match this to the Firmata sketch in use.

        :param arduino_instance_id: If you are using the Firmata
                                    Express sketch, match this
                                    value to that in the sketch.

        :param arduino_wait: Amount of time to wait for an Arduino to
                             fully reset itself.

        :param sleep_tune: A tuning parameter (typically not changed by user)

        :param shutdown_on_exception: call shutdown before raising
                                      a RunTimeError exception, or
                                      receiving a KeyboardInterrupt exception

        :param ip_address: Used with StandardFirmataWifi to specify IP address of
                           the WiFi device

        :param ip_port: Used with StandardFirmataWifi to specify IP port of
                           the WiFi device. Typically this is 3030

        &#34;&#34;&#34;
        self.start_time = time.time()
        # initialize threading parent
        threading.Thread.__init__(self)

        # create the threads and set them as daemons so
        # that they stop when the program is closed

        # create a thread to interpret received serial data
        self.the_reporter_thread = threading.Thread(target=self._reporter)
        self.the_reporter_thread.daemon = True

        self.ip_address = ip_address
        self.ip_port = ip_port

        # if an ip address was specified, tcp/ip will be used instead of serial
        # transfer.
        # create a thread to continuously receive data
        if self.ip_address:
            self.the_data_receive_thread = threading.Thread(target=self._tcp_receiver)
        else:
            self.the_data_receive_thread = threading.Thread(target=self._serial_receiver)

        self.the_data_receive_thread.daemon = True

        self.i2c_configured = False

        # flag to allow the reporter and receive threads to run.
        self.run_event = threading.Event()

        # instance variable
        self.ina219 = None

        # callback function
        self.ina219_callback = None

        # ina_219 values - last values retrieved
        self.ina_last_value_bus_voltage = []
        self.ina_last_value_bus_current = []
        self.ina_last_value_supply_voltage = []
        self.ina_last_value_shunt_voltage = []
        self.ina_last_value_power = []

        # mpu_9250 threading
        self.mpu_9250_thread = threading.Thread(target=self._mpu_read_device)
        self.mpu_9250_thread.daemon = True
        self.mpu_9250_device = None
        self.mpu_callback = None
        self.mpu_last_value = []
        self.mpu_constants = mpu_constants

        self.mpu_read_delay = 0.3  # delay between reads

        # flag to allow mpu_9250 to run
        self.mpu_9250_run_event = threading.Event()

        # check to make sure that Python interpreter is version 3.7 or greater
        python_version = sys.version_info
        if python_version[0] &gt;= 3:
            if python_version[1] &gt;= 7:
                pass
            else:
                raise RuntimeError(&#34;ERROR: Python 3.7 or greater is &#34;
                                   &#34;required for use of this program.&#34;)

        # save input parameters as instance variables
        self.com_port = com_port
        self.baud_rate = baud_rate
        self.arduino_instance_id = arduino_instance_id
        self.arduino_wait = arduino_wait
        self.sleep_tune = sleep_tune
        self.shutdown_on_exception = shutdown_on_exception

        # create a deque to receive and process data from the arduino
        self.the_deque = deque()

        # The report_dispatch dictionary is used to process
        # incoming report sysex message by looking up the sysex command
        # and executing its associated processing method.
        # The value following the method is the number of bytes to
        # retrieve from the deque to process the command.
        self.report_dispatch = {}

        # To add a command to the command dispatch table, append here.
        self.report_dispatch.update({PrivateConstants.REPORT_VERSION: [self._report_version, 2]})
        self.report_dispatch.update({PrivateConstants.REPORT_FIRMWARE: [self._report_firmware, 1]})
        self.report_dispatch.update({PrivateConstants.ANALOG_MESSAGE: [self._analog_message, 2]})
        self.report_dispatch.update({PrivateConstants.DIGITAL_MESSAGE: [self._digital_message, 2]})
        self.report_dispatch.update({PrivateConstants.SONAR_DATA: [self._sonar_data, 3]})
        self.report_dispatch.update({PrivateConstants.STRING_DATA: [self._string_data, 2]})
        self.report_dispatch.update({PrivateConstants.I2C_REPLY: [self._i2c_reply, 2]})
        self.report_dispatch.update({PrivateConstants.CAPABILITY_RESPONSE: [self._capability_response, 2]})
        self.report_dispatch.update({PrivateConstants.PIN_STATE_RESPONSE: [self._pin_state_response, 2]})
        self.report_dispatch.update({PrivateConstants.ANALOG_MAPPING_RESPONSE: [self._analog_mapping_response, 4]})
        self.report_dispatch.update({PrivateConstants.DHT_DATA: [self._dht_read_response, 7]})

        # report query results are stored in this dictionary
        self.query_reply_data = {PrivateConstants.REPORT_VERSION: &#39;&#39;,
                                 PrivateConstants.STRING_DATA: &#39;&#39;,
                                 PrivateConstants.REPORT_FIRMWARE: &#39;&#39;,
                                 PrivateConstants.CAPABILITY_RESPONSE: None,
                                 PrivateConstants.ANALOG_MAPPING_RESPONSE:
                                     None,
                                 PrivateConstants.PIN_STATE_RESPONSE: None}

        self.firmata_firmware = []

        # a flag to indicate if using FirmataExpress
        self.using_firmata_express = False

        # dht error flag
        self.dht_sensor_error = False

        # a list of PinData objects - one for each pin segregated by pin type
        # see pin_data.py
        self.analog_pins = []
        self.digital_pins = []

        # a list of pins assigned to DHT devices
        self.dht_list = []

        # This lock is used when the PinData object is update or contents
        # are retrieved
        self.the_pin_data_lock = threading.Lock()

        # a lock for sending i2c commands
        self.the_i2c_send_lock = threading.RLock()

        # a lock for the i2c map data structure
        self.the_i2c_map_lock = threading.Lock()

        # a lock for the sonar map
        self.the_sonar_map_lock = threading.Lock()

        # a when sending data to the arduino
        self.the_send_sysex_lock = threading.Lock()

        # serial port in use
        self.serial_port = None

        # handle to tcp/ip socket
        self.sock = None

        # An i2c_map entry consists of a device i2c address as the key, and
        #  the value of the key consists of a dictionary containing 2 entries.
        #  The first entry. &#39;value&#39; contains the last value reported, and
        # the second, &#39;callback&#39; contains a reference to a callback function,
        # and the third, a time-stamp
        # For example:
        # {12345: {&#39;value&#39;: 23, &#39;callback&#39;: None, time_stamp:None}}
        self.i2c_map = {}

        # The active_sonar_map maps the sonar trigger pin number (the key)
        # to the current data value returned
        # if a callback was specified, it is stored in the map as well.
        # A map entry consists of:
        #   pin: [callback, current_data_returned, time_stamp]
        self.active_sonar_map = {}

        # first analog pin number
        self.first_analog_pin = None

        # flag to indicate we are in shutdown mode
        self.shutdown_flag = False

        print(f&#34;pymata4:  Version {PrivateConstants.PYMATA_EXPRESS_THREADED_VERSION}\n\n&#34;
              f&#34;Copyright (c) 2020 Alan Yorinks All Rights Reserved.\n&#34;)
        # if this is not a tcp interface, find the serial port
        if not self.ip_address:
            if not self.com_port:
                # user did not specify a com_port
                try:
                    self._find_arduino()
                except KeyboardInterrupt:
                    if self.shutdown_on_exception:
                        self.shutdown()
            else:
                # com_port specified - set com_port and baud rate
                try:
                    self._manual_open()
                except KeyboardInterrupt:
                    if self.shutdown_on_exception:
                        self.shutdown()

            if self.serial_port:
                print(f&#34;Arduino compatible device found and connected to {self.serial_port.port}&#34;)

            # no com_port found - raise a runtime exception
            else:
                if self.shutdown_on_exception:
                    self.shutdown()
                raise RuntimeError(&#39;No Arduino Found or User Aborted Program&#39;)
        # this is tcp/ip interface
        else:
            # with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as self.sock:
            #     s = self.sock.create_connection((self.ip_address, self.ip_port))
            #     print(s)
            self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.sock.connect((self.ip_address, self.ip_port))
            print(f&#39;Successfully connected to: {self.ip_address}:{self.ip_port}&#39;)

        self.the_reporter_thread.start()
        self.the_data_receive_thread.start()
        self.mpu_9250_thread.start()
        # allow the threads to run
        self._run_threads()

        # get arduino firmware version and print it
        try:
            print(&#39;\nRetrieving Arduino Firmware ID...&#39;)
            firmware_version = self.get_firmware_version()

            if not firmware_version:
                if self.shutdown_on_exception:
                    self.shutdown()
                raise RuntimeError(f&#39;Firmata Sketch Firmware Version Not Found&#39;)
            else:
                if self.using_firmata_express:
                    version_number = firmware_version[0:3]
                    if version_number != PrivateConstants.FIRMATA_EXPRESS_VERSION:
                        raise RuntimeError(f&#39;You must use FirmataExpress version 1.1. Version Found = {version_number}&#39;)
                print(f&#39;Arduino Firmware ID: {firmware_version}&#39;)
        except TypeError:
            print(&#39;\nIs your serial cable plugged in and do you have the &#39;
                  &#39;correct Firmata sketch loaded?&#39;)
            print(&#39;Is the COM port correct?&#39;)
            print(&#39;To see a list of serial ports, type: &#34;list_serial_ports&#34; &#39;
                  &#39;in your console.&#39;)
            raise RuntimeError
        except KeyboardInterrupt:
            if self.shutdown_on_exception:
                self.shutdown()
            raise RuntimeError(&#39;No Arduino Found or User Aborted Program&#39;)

        print(&#39;\nRetrieving analog map...&#39;)

        # try to get an analog pin map. if it comes back as none raise an exception

        report = self.get_analog_map()
        if not report:
            if self.shutdown_on_exception:
                self.shutdown()
            raise RuntimeError(f&#39;*** Analog map retrieval timed out. ***&#39;
                               f&#39;\nDo you have Arduino connectivity and do you have the &#39;
                               f&#39;correct Firmata sketch uploaded to the board?&#39;)

        # custom assemble the pin lists
        try:
            for pin in report:
                digital_data = PinData(self.the_pin_data_lock)
                self.digital_pins.append(digital_data)
                if pin != PrivateConstants.IGNORE:
                    analog_data = PinData(self.the_pin_data_lock)
                    self.analog_pins.append(analog_data)

            print(f&#39;Auto-discovery complete. Found {len(self.digital_pins)} Digital Pins&#39;
                  f&#39; and {len(self.analog_pins)} Analog Pins\n\n&#39;)
            self.first_analog_pin = len(self.digital_pins) - len(self.analog_pins)
        except KeyboardInterrupt:
            if self.shutdown_on_exception:
                self.shutdown()
            raise RuntimeError(&#39;User Hit Control-C&#39;)

        # Set the sampling interval to the standard value
        # so the the DHT and HC-SRO4 device report at the right
        # time frame.
        self.set_sampling_interval(19)

    def _find_arduino(self):
        &#34;&#34;&#34;
        This method will search all potential serial ports for an Arduino
        containing a sketch that has a matching arduino_instance_id as
        specified in the input parameters of this class.

        This is used explicitly with the FirmataExpress sketch.
        &#34;&#34;&#34;

        # a list of serial ports to be checked
        serial_ports = []

        print(&#39;Opening all potential serial ports...&#39;)
        the_ports_list = list_ports.comports()
        for port in the_ports_list:
            if port.pid is None:
                continue
            try:
                self.serial_port = serial.Serial(port.device, self.baud_rate,
                                                 timeout=1, writeTimeout=0)
            except SerialException:
                continue
            # create a list of serial ports that we opened
            serial_ports.append(self.serial_port)

            # display to the user
            print(&#39;\t&#39; + port.device)

            # clear out any possible data in the input buffer
            self.serial_port.reset_input_buffer()
            self.serial_port.reset_output_buffer()

        # wait for arduino to reset
        print(f&#39;\nWaiting {self.arduino_wait} seconds(arduino_wait) for Arduino devices to &#39;
              &#39;reset...&#39;)
        try:
            time.sleep(self.arduino_wait)

            print(f&#39;\nSearching for an Arduino configured with an arduino_instance = {self.arduino_instance_id}&#39;)

            for serial_port in serial_ports:
                self.serial_port = serial_port
                # send the &#34;are you there&#34; sysex request to the arduino
                self._send_sysex(PrivateConstants.ARE_YOU_THERE)

                # wait until the END_SYSEX comes back
                i_am_here = self.serial_port.read_until(b&#39;\xf7&#39;)

                if not i_am_here:
                    continue

                # make sure we get back the expected length
                if len(i_am_here) != 4:
                    continue

                # convert i_am_here to a list
                i_am_here = list(i_am_here)

                # check sysex command is I_AM_HERE
                if i_am_here[1] != PrivateConstants.I_AM_HERE:
                    continue
                else:
                    # got an I am here message - is it the correct ID?
                    if i_am_here[2] == self.arduino_instance_id:
                        self.using_firmata_express = True
                        self.com_port = self.serial_port
                        return
        except KeyboardInterrupt:
            raise RuntimeError(&#39;User Hit Control-C&#39;)

    def _manual_open(self):
        &#34;&#34;&#34;
        Com port was specified by the user - try to open up that port

        &#34;&#34;&#34;
        # if port is not found, a serial exception will be thrown
        try:
            print(f&#39;Opening {self.com_port}...&#39;)
            self.serial_port = serial.Serial(self.com_port, self.baud_rate,
                                             timeout=1, writeTimeout=0)

            print(f&#39;\nWaiting {self.arduino_wait} seconds(arduino_wait) for Arduino devices to &#39;
                  &#39;reset...&#39;)
            time.sleep(self.arduino_wait)
            # time.sleep(self.arduino_wait)
            if self.baud_rate == 115200:
                self._send_sysex(PrivateConstants.ARE_YOU_THERE)

                # wait until the END_SYSEX comes back
                i_am_here = self.serial_port.read_until(b&#39;\xf7&#39;)

                # convert i_am_here to a list
                i_am_here = list(i_am_here)

                if len(i_am_here) != 4:
                    raise RuntimeError(&#39;Invalid Arduino ID reply length&#39;)

                # check sysex command is I_AM_HERE
                if i_am_here[1] != PrivateConstants.I_AM_HERE:
                    raise RuntimeError(&#39;Retrieving ID From Arduino Failed.&#39;)
                else:
                    # got an I am here message - is it the correct ID?
                    if i_am_here[2] == self.arduino_instance_id:
                        return
                    else:
                        raise RuntimeError(&#39;Invalid Arduino identifier retrieved&#39;)
        except KeyboardInterrupt:
            raise RuntimeError(&#39;User Hit Control-C&#39;)

    def analog_read(self, pin):
        &#34;&#34;&#34;
        Retrieve the last data update for the specified analog pin.

        :param pin: Analog pin number (ex. A2 is specified as 2)

        :returns: A list = [last value change,  time_stamp]
        &#34;&#34;&#34;
        return self.analog_pins[pin].current_value, self.analog_pins[pin].event_time

    def dht_read(self, pin):
        &#34;&#34;&#34;
        Retrieve the last data update for the specified dht pin.

        :param pin: digital pin number

        :return: A list = [humidity, temperature  time_stamp]

                 ERROR CODES: If either humidity or temperature value:
                              == -1 Configuration Error
                              == -2 Checksum Error
                              == -3 Timeout Error

        &#34;&#34;&#34;
        return self.digital_pins[pin].current_value[0], \
               self.digital_pins[pin].current_value[1], \
               self.digital_pins[pin].event_time

    def digital_read(self, pin):
        &#34;&#34;&#34;
        Retrieve the last data update for the specified digital pin.

        :param pin: Digital pin number

        :returns: A list = [last value change,  time_stamp]

        &#34;&#34;&#34;
        return [self.digital_pins[pin].current_value, self.digital_pins[pin].event_time]

    def digital_write(self, pin, value):
        &#34;&#34;&#34;
        Set the specified pin to the specified value.

        :param pin: arduino pin number

        :param value: pin value (1 or 0)

        &#34;&#34;&#34;
        # The command value is not a fixed value, but needs to be calculated
        # using the pin&#39;s port number
        port = pin // 8

        calculated_command = PrivateConstants.DIGITAL_MESSAGE + port
        mask = 1 &lt;&lt; (pin % 8)
        # Calculate the value for the pin&#39;s position in the port mask
        if value == 1:
            PrivateConstants.DIGITAL_OUTPUT_PORT_PINS[port] |= mask
        else:
            PrivateConstants.DIGITAL_OUTPUT_PORT_PINS[port] &amp;= ~mask

        # Assemble the command
        command = (calculated_command,
                   PrivateConstants.DIGITAL_OUTPUT_PORT_PINS[port] &amp; 0x7f,
                   (PrivateConstants.DIGITAL_OUTPUT_PORT_PINS[port] &gt;&gt; 7)
                   &amp; 0x7f)

        self._send_command(command)

    def disable_analog_reporting(self, pin):
        &#34;&#34;&#34;
        Disables analog reporting for a single analog pin.

        :param pin: Analog pin number. For example for A0, the number is 0.

        &#34;&#34;&#34;
        pin = pin + self.first_analog_pin
        self.set_pin_mode_digital_input(pin)

    def disable_digital_reporting(self, pin):
        &#34;&#34;&#34;
        Disables digital reporting. By turning reporting off for this pin,
        Reporting is disabled for all 8 bits in the &#34;port&#34;

        :param pin: Pin and all pins for this port

        &#34;&#34;&#34;
        port = pin // 8
        command = [PrivateConstants.REPORT_DIGITAL + port,
                   PrivateConstants.REPORTING_DISABLE]
        self._send_command(command)

    def enable_analog_reporting(self, pin, callback=None, differential=1):
        &#34;&#34;&#34;
        Enables analog reporting. This is an alias for set_pin_mode_analog_input.
        Disabling analog reporting sets the pin to a digital input pin,
        so we need to provide the callback and differential if we wish
        to specify it.

        :param pin: Analog pin number. For example for A0, the number is 0.

        :param callback: callback function

        :param differential: This value needs to be met for a callback
                             to be invoked.
        &#34;&#34;&#34;
        self.set_pin_mode_analog_input(pin, callback, differential)

    def enable_digital_reporting(self, pin):
        &#34;&#34;&#34;
        Enables digital reporting. By turning reporting on for all 8 bits
        in the &#34;port&#34; - this is part of Firmata&#39;s protocol specification.

        :param pin: Pin and all pins for this port

        :returns: No return value
            &#34;&#34;&#34;
        port = pin // 8
        command = [PrivateConstants.REPORT_DIGITAL + port,
                   PrivateConstants.REPORTING_ENABLE]
        self._send_command(command)

    def get_analog_map(self):
        &#34;&#34;&#34;
        This method requests a Firmata analog map query and returns the
        results.

        :returns: An analog map response or None if a timeout occurs
        &#34;&#34;&#34;
        # get the current time to make sure a report is retrieved
        current_time = time.time()

        # if we do not have existing report results, send a Firmata
        # message to request one

        self._send_sysex(PrivateConstants.ANALOG_MAPPING_QUERY)
        # wait for the report results to return for 4 seconds
        # if the timer expires, return None
        while self.query_reply_data.get(
                PrivateConstants.ANALOG_MAPPING_RESPONSE) is None:
            elapsed_time = time.time()
            if elapsed_time - current_time &gt; 4:
                return None
            # time.sleep(self.sleep_tune)
            time.sleep(.01)
        return self.query_reply_data.get(PrivateConstants.ANALOG_MAPPING_RESPONSE)

    def get_capability_report(self):
        &#34;&#34;&#34;
        This method requests and returns a Firmata capability query report

        :returns: A capability report in the form of a list
        &#34;&#34;&#34;

        self._send_sysex(PrivateConstants.CAPABILITY_QUERY)
        while self.query_reply_data.get(
                PrivateConstants.CAPABILITY_RESPONSE) is None:
            time.sleep(self.sleep_tune)
        return self.query_reply_data.get(PrivateConstants.CAPABILITY_RESPONSE)

    def get_firmware_version(self):
        &#34;&#34;&#34;
        This method retrieves the Firmata firmware version

        :returns: Firmata firmware version
        &#34;&#34;&#34;
        self._send_sysex(PrivateConstants.REPORT_FIRMWARE)

        current_time = time.time()
        while self.query_reply_data.get(PrivateConstants.REPORT_FIRMWARE) == &#39;&#39;:
            elapsed_time = time.time()
            if elapsed_time - current_time &gt; 4:
                return None
            time.sleep(self.sleep_tune)
        return self.query_reply_data.get(PrivateConstants.REPORT_FIRMWARE)

    def get_protocol_version(self):
        &#34;&#34;&#34;
        This method returns the major and minor values for the protocol
        version, i.e. 2.5

        :returns: Firmata protocol version
        &#34;&#34;&#34;
        self._send_command([PrivateConstants.REPORT_VERSION])
        while self.query_reply_data.get(
                PrivateConstants.REPORT_VERSION) == &#39;&#39;:
            time.sleep(self.sleep_tune)
        # v_major =
        return self.query_reply_data.get(PrivateConstants.REPORT_VERSION)

    def get_pin_state(self, pin):
        &#34;&#34;&#34;
        This method retrieves a pin state report for the specified pin.
        Pin modes reported:

        INPUT   = 0x00  # digital input mode

        OUTPUT  = 0x01  # digital output mode

        ANALOG  = 0x02  # analog input mode

        PWM     = 0x03  # digital pin in PWM output mode

        SERVO   = 0x04  # digital pin in Servo output mode

        I2C     = 0x06  # pin included in I2C setup

        STEPPER = 0x08  # digital pin in stepper mode

        PULLUP  = 0x0b  # digital pin in input pullup mode

        SONAR   = 0x0c  # digital pin in SONAR mode

        TONE    = 0x0d  # digital pin in tone mode

        :param pin: Pin of interest

        :returns: pin state report

        &#34;&#34;&#34;
        # place pin in a list to keep _send_sysex happy
        self._send_sysex(PrivateConstants.PIN_STATE_QUERY, [pin])
        while self.query_reply_data.get(
                PrivateConstants.PIN_STATE_RESPONSE) is None:
            time.sleep(self.sleep_tune)
        pin_state_report = self.query_reply_data.get(
            PrivateConstants.PIN_STATE_RESPONSE)
        self.query_reply_data[PrivateConstants.PIN_STATE_RESPONSE] = None
        return pin_state_report

    # noinspection PyMethodMayBeStatic
    def get_pymata_version(self):
        &#34;&#34;&#34;
        This method retrieves the PyMata Express version number

        :returns: PyMata Express version number.
        &#34;&#34;&#34;
        return PrivateConstants.PYMATA_EXPRESS_THREADED_VERSION

    def i2c_read_saved_data(self, address):
        &#34;&#34;&#34;
        This method retrieves cached i2c data to support a polling mode.

        :param address: I2C device address

        :returns data: [raw data returned from i2c device, time-stamp]

        &#34;&#34;&#34;
        if address in self.i2c_map:
            with self.the_i2c_map_lock:
                map_entry = self.i2c_map.get(address)
                return map_entry.get(&#39;value&#39;)
        else:
            return None

    def i2c_read(self, address, register, number_of_bytes,
                 callback=None):
        &#34;&#34;&#34;
        Read the specified number of bytes from the specified register for
        the i2c device.


        :param address: i2c device address

        :param register: i2c register (or None if no register selection is needed)

        :param number_of_bytes: number of bytes to be read

        :param callback: Optional callback function to report i2c data as a
                   result of read command


        callback returns a data list:

        [pin_type, i2c_device_address, i2c_read_register, data_bytes returned, time_stamp]

        The pin_type for i2c = 6

        &#34;&#34;&#34;
        with self.the_i2c_send_lock:
            self._i2c_read_request(address, register, number_of_bytes,
                                   PrivateConstants.I2C_READ, callback)

    def i2c_read_continuous(self, address, register, number_of_bytes,
                            callback=None):
        &#34;&#34;&#34;
        Some i2c devices support a continuous streaming data output.
        This command enables that mode for the device that supports
        continuous reads.


        :param address: i2c device address

        :param register: i2c register (or None if no register selection is needed)

        :param number_of_bytes: number of bytes to be read

        :param callback: Optional callback function to report i2c data as a
                   result of read command


        callback returns a data list:

        [pin_type, i2c_device_address, i2c_read_register, data_bytes returned, time_stamp]

        The pin_type for i2c = 6


        &#34;&#34;&#34;
        with self.the_i2c_send_lock:
            self._i2c_read_request(address, register, number_of_bytes,
                                   PrivateConstants.I2C_READ_CONTINUOUSLY,
                                   callback)

    def i2c_read_restart_transmission(self, address, register,
                                      number_of_bytes,
                                      callback=None):
        &#34;&#34;&#34;
        Read the specified number of bytes from the specified register for
        the i2c device. This restarts the transmission after the read. It is
        required for some i2c devices such as the MMA8452Q accelerometer.


        :param address: i2c device address

        :param register: i2c register (or None if no register
                                                    selection is needed)

        :param number_of_bytes: number of bytes to be read

        :param callback: Optional callback function to report i2c data as a
                   result of read command


        callback returns a data list:

        [pin_type, i2c_device_address, i2c_read_register, data_bytes returned, time_stamp]

        The pin_type for i2c pins = 6

        &#34;&#34;&#34;
        with self.the_i2c_send_lock:
            self._i2c_read_request(address, register, number_of_bytes,
                                   PrivateConstants.I2C_READ
                                   | PrivateConstants.I2C_END_TX_MASK,
                                   callback)

    def _i2c_read_request(self, address, register, number_of_bytes, read_type,
                          callback=None):
        &#34;&#34;&#34;
        This method requests the read of an i2c device. Results are retrieved
        by a call to i2c_get_read_data(). or by callback.

        If a callback method is provided, when data is received from the
        device it will be sent to the callback method.

        Some devices require that transmission be restarted
        (e.g. MMA8452Q accelerometer).

        I2C_READ | I2C_END_TX_MASK values for the read_type in those cases.

        I2C_READ = 0B00001000

        I2C_READ_CONTINUOUSLY = 0B00010000

        I2C_STOP_READING = 0B00011000

        I2C_END_TX_MASK = 0B01000000

        :param address: i2c device address

        :param register: register number (or None if no register selection is needed)

        :param number_of_bytes: number of bytes expected to be returned

        :param read_type: I2C_READ  or I2C_READ_CONTINUOUSLY. I2C_END_TX_MASK
                          may be OR&#39;ed when required

        :param callback: Optional callback function to report i2c data as a
                   result of read command

        &#34;&#34;&#34;
        with self.the_i2c_send_lock:
            if address not in self.i2c_map:
                with self.the_i2c_map_lock:
                    self.i2c_map[address] = {&#39;value&#39;: None, &#39;callback&#39;: callback}
            if register is not None:
                data = [address, read_type, register &amp; 0x7f, (register &gt;&gt; 7) &amp; 0x7f,
                        number_of_bytes &amp; 0x7f, (number_of_bytes &gt;&gt; 7) &amp; 0x7f]
            else:
                data = [address, read_type,
                        number_of_bytes &amp; 0x7f, (number_of_bytes &gt;&gt; 7) &amp; 0x7f]
            self._send_sysex(PrivateConstants.I2C_REQUEST, data)

    def i2c_write(self, address, args):
        &#34;&#34;&#34;
        Write data to an i2c device.

        :param address: i2c device address

        :param args: A variable number of bytes to be sent to the device
                     passed in as a list

        &#34;&#34;&#34;
        with self.the_i2c_send_lock:
            data = [address, PrivateConstants.I2C_WRITE]
            for item in args:
                item_lsb = item &amp; 0x7f
                data.append(item_lsb)
                item_msb = (item &gt;&gt; 7) &amp; 0x7f
                data.append(item_msb)
            self._send_sysex(PrivateConstants.I2C_REQUEST, data)

    def ina_initialize(self, address=0x40, shunt_ohms=0.2,
                       max_expected_amps=0.2, callback=None):
        &#34;&#34;&#34;
        This method instantiates an INA219 object.

        :param address: The i2c address of the device

        :param shunt_ohms: The shunt resistance in ohms

        :param max_expected_amps: The maximum expected current in amps

        :param callback: Callback method that will INA219 callbacks

        Note: There is a single callback shared by all INA methods.

        &#34;&#34;&#34;
        # make sure that we initialize i2c mode
        self.set_pin_mode_i2c()

        # instantiate ina_219 and save callback
        self.ina219 = INA219(self, shunt_ohms, max_expected_amps, address)
        self.ina219.configure(self.ina219.RANGE_16V, self.ina219.GAIN_AUTO)
        self.ina219_callback = callback

    def ina_read_bus_voltage(self):
        &#34;&#34;&#34;
        This method well execute a read of the bus voltage.
        If a callback was specified in ina_initialize, then
        a callback frame is specified as follows:

        [pin_type=0x11, device_i2c_address, read_type=0 (bus voltage), voltage, units=&#39;V&#39;, timestamp]

        The data is also saved to be retrieved by ina_read_supply_voltage_last()

        :return: callback is called and storage updated with latest value
        &#34;&#34;&#34;
        # noinspection PyProtectedMember
        self.ina219.voltage()

    def ina_read_bus_voltage_last(self):
        &#34;&#34;&#34;
        Retrieve last bus voltage value read from the ina_219.

        :return: list: [pin_type=0x11, device_i2c_address, read_type=0 (bus voltage), units=&#39;V&#39;, timestamp]
        &#34;&#34;&#34;
        return self.ina_last_value_bus_voltage

    def ina_read_bus_current(self):
        &#34;&#34;&#34;
        This method well execute a read of the bus current.
        If a callback was specified in ina_initialize, then
        a callback frame is specified as follows:

        [pin_type=0x11, device_i2c_address, read_type=1 (bus current), current, units=&#39;mA&#39;, timestamp]

        The data is also saved to be retrieved by ina_read_bus_current_last()

        :return: callback is called and storage updated with latest value
        &#34;&#34;&#34;
        # noinspection PyProtectedMember
        self.ina219.current()

    def ina_read_bus_current_last(self):
        &#34;&#34;&#34;
        Retrieve last supply voltage value read from the ina_219.


        :return: list:

        [pin_type=0x11, device_i2c_address, read_type=1 (bus voltage), voltage, units=&#39;mA&#39;, timestamp]
        &#34;&#34;&#34;
        return self.ina_last_value_bus_current

    def ina_read_supply_voltage(self):
        &#34;&#34;&#34;
        This method well execute a read of the supply voltage.
        If a callback was specified in ina_initialize, then
        a callback frame is specified as follows:

        [pin_type=0x11, device_i2c_address, read_type=2 (supply voltage), supply voltage, unit=&#39;V&#39;,timestamp]

        The data is also saved to be retrieved by ina_read_supply_voltage_last()

        :return: callback is called and storage updated with latest value
        &#34;&#34;&#34;
        # noinspection PyProtectedMember
        self.ina219.supply_voltage()

    def ina_read_supply_voltage_last(self):
        &#34;&#34;&#34;
        This method retrieves the last supply voltage read.

        :return: list:

        [pin_type=0x11, device_i2c_address, read_type=2 (supply voltage), voltage, units=&#39;V&#39;, timestamp]

        &#34;&#34;&#34;
        return self.ina_last_value_supply_voltage

    def ina_read_shunt_voltage(self):
        &#34;&#34;&#34;
        This method well execute a read of the shunt voltage.
        If a callback was specified in ina_initialize, then
        a callback frame is specified as follows:

        [pin_type=0x11, device_i2c_address, read_type=3 (supply voltage), shunt voltage, units=&#39;mV&#39;, timestamp]

        The data is also saved to be retrieved by ina_read_shunt_voltage_last()

        :return: callback is called and storage updated with latest value
        &#34;&#34;&#34;
        # noinspection PyProtectedMember
        self.ina219.shunt_voltage()

    def ina_read_shunt_voltage_last(self):
        &#34;&#34;&#34;
        This method well execute a read of the shunt voltage.
        If a callback was specified in ina_initialize, then
        a callback frame is specified as follows:


        :return: list:
        [pin_type=0x11, device_i2c_address, read_type=3 (shunt voltage), shunt voltage, units=&#39;mV&#39;, timestamp]
        &#34;&#34;&#34;

        # noinspection PyProtectedMember
        return self.ina_last_value_shunt_voltage

    def ina_read_power(self):
        &#34;&#34;&#34;
        This method well execute a read of the power.
        If a callback was specified in ina_initialize, then
        a callback frame is specified as follows:

        [pin_type=0x11, device_i2c_address, read_type=4 (power), power, units=&#39;mW&#39;, timestamp]

        The data is also saved to be retrieved by ina_read_power_last()

        :return: callback is called and storage updated with latest value
        &#34;&#34;&#34;
        # noinspection PyProtectedMember
        self.ina219.power()

    def ina_read_power_last(self):
        &#34;&#34;&#34;
        This method retrieves the last read power value.

        :return: list:
                [pin_type=0x11, device_i2c_address, read_type=4 (power), power, units=&#39;mW&#39;, timestamp]

        &#34;&#34;&#34;

        # noinspection PyProtectedMember
        return self.ina_last_value_power

    def ina_sleep(self):
        self.ina219.ina_sleep()

    def ina_wake(self):
        self.ina219.ina_wake()

    def mpu_9250_calibrate(self, log=True):
        &#34;&#34;&#34;
        This method will calibrate the device. This is a lengthy process
        and may take about a minute to complete.

        This method will:
        1. Test if the mpu_9250 was initialized and if not, it will
           initialize with the default values.
        2. Print the current device settings.
        3. Run the calibrations for both the calibrate_ak8963 and MPU6050.
        4. Configure the device with the new settings.
        5. Print the new device settings.

        :param: logging - If set to true calibration data is logged to a file
                          named mpu_calibration.log

        :return: If an error is encountered a RunTimeError exception is raised.
        &#34;&#34;&#34;
        if logging:
            logging.basicConfig(filename=&#39;mpu_calibration.log&#39;, filemode=&#39;a&#39;, level=logging.DEBUG)
            print(&#39;Configuration data being logged to mpu_calibration.log&#39;)

        if not self.mpu_9250_device:
            print(&#39;Initializing mpu9250&#39;)
            self.mpu_9250_initialize()
        print(&#39;Settings Before Calibration:&#39;)
        if log:
            logging.info(&#39;&#39;)
            logging.info(f&#39;Calibration Date: {datetime.datetime.now()}&#39;)
            logging.info(&#39;Settings Before Calibration:&#39;)

        print()
        if log:
            self._mpu_9250_get_current_settings(log=True)
        else:
            self._mpu_9250_get_current_settings(log=False)
        print()
        print(&#39;Calibrating ...&#39;)
        print()
        self.mpu_9250_device.calibrate()

        print(&#39;Configuring with calibrated values...&#39;)
        print()
        self.mpu_9250_device.configure()
        print()

        print(&#39;Settings After Calibration:&#39;)
        if log:
            logging.info(&#39;Settings After Calibration:&#39;)
        print()
        if log:
            self._mpu_9250_get_current_settings(log=True)
        else:
            self._mpu_9250_get_current_settings(log=False)

        print()

    def _mpu_9250_get_current_settings(self, log):
        &#34;&#34;&#34;
        Retrieve and print the current mpu9250 settings

        :return: Settings are printed to console
        &#34;&#34;&#34;
        settings = self.mpu_9250_device.get_all_settings()
        print(f&#39;MPU Address: {settings[0]}&#39;)
        print(f&#39;AK Address: {settings[1]}&#39;)
        print(f&#39;Accel Resolution: {settings[3]}&#39;)
        print(f&#39;Gyro Resolution: {settings[2]}&#39;)
        print(f&#39;Mag Resolution: {settings[4]}&#39;)
        print(f&#39;Accel Bias: {tuple(settings[8:11])}&#39;)
        print(f&#39;Gyro Bias: {tuple(settings[5:8])}&#39;)
        print(f&#39;Mag Bias: {tuple(settings[17:20])}&#39;)
        print(f&#39;Mag Calibration: {tuple(settings[11:14])}&#39;)
        print(f&#39;Mag Scale: {tuple(settings[14:17])}&#39;)

        if log:
            logging.info(f&#39;MPU Address: {settings[0]}&#39;)
            logging.info(f&#39;AK Address: {settings[1]}&#39;)
            logging.info(f&#39;Accel Resolution: {settings[3]}&#39;)
            logging.info(f&#39;Gyro Resolution: {settings[2]}&#39;)
            logging.info(f&#39;Mag Resolution: {settings[4]}&#39;)
            logging.info(f&#39;Accel Bias: {tuple(settings[8:11])}&#39;)
            logging.info(f&#39;Gyro Bias: {tuple(settings[5:8])}&#39;)
            logging.info(f&#39;Mag Bias: {tuple(settings[17:20])}&#39;)
            logging.info(f&#39;Mag Calibration: {tuple(settings[11:14])}&#39;)
            logging.info(f&#39;Mag Scale: {tuple(settings[14:17])}&#39;)

    def mpu_9250_initialize(self, address_ak=mpu_constants.AK8963_ADDRESS,
                            address_mpu=mpu_constants.MPU9250_ADDRESS_69,
                            g_fs=mpu_constants.GFS_500,
                            a_fs=mpu_constants.AFS_2G,
                            m_fs=mpu_constants.AK8963_BIT_16,
                            mode=mpu_constants.AK8963_MODE_C8HZ,
                            a_bias=(0, 0, 0), g_bias=(0, 0, 0),
                            m_bias=(0, 0, 0),
                            mag_scale=(1, 1, 1),
                            callback=None
                            ):
        &#34;&#34;&#34;
        This method instantiates an mpu_9250 object.
        It also creates the thread to manage the mpu_9250 data retrieval.

        :param address_ak: AK8963 I2C address (default:AK8963_ADDRESS[0x0C]).

        :param address_mpu:  MPU-9250 I2C address (default:MPU9050_ADDRESS_68[0x68]).

        :param g_fs: Gyroscope full scale select (default:GFS_2000[2000dps]).

        :param a_fs: Accelerometer full scale select (default:AFS_16G[16g]).

        :param m_fs: Magnetometer scale select (default:AK8963_BIT_16[16bit])

        :param mode: Magnetometer mode select (default:AK8963_MODE_C8HZ)

        :param a_bias: Accelerometer Bias

        :param g_bias: Gyroscope Bias

        :param m_bias: Magnetometer Hard Iron Distortion

        :param mag_scale: Magnetometer Soft Iron Distortion

        :param callback: Callback method that will receive mpu data frames

        &#34;&#34;&#34;
        self.mpu_callback = callback

        # make sure that we initialize i2c mode
        self.set_pin_mode_i2c()

        self.mpu_9250_device = MPU9250(self, address_ak, address_mpu,
                                       g_fs, a_fs, m_fs, mode,
                                       mag_scale=mag_scale, g_bias=g_bias,
                                       a_bias=a_bias, m_bias=m_bias)
        self.mpu_callback = callback

    def mpu_9250_read_data(self, mode=mpu_constants.MPU9250_READ_CONTINUOUS_ON,
                           continuous_delay=0.3):
        &#34;&#34;&#34;
        Read and report mpu_9250 data for accelerometer, gyroscope,
        magnetometer, and device temperature.

        :param mode: MPU9250_READ_CONTINUOUS_ON(0) - data is read continuously, or
                     MPU9250_READ_CONTINUOUS_OFF - turn off continuous reads.

        :param continuous_delay: Delay between reads

        :return: For MPU9250_READ_CONTINUOUS_ON, if a callback was specified in
        mpu_9250_initialize(), then data returned is returned via callback.

                 Callback data is a list with format:
                 index[0] = pin type - for mpu9250 the value is 16
                 index[1] = mpu address
                 index[2] = accelerometer x axis
                 index[3] = accelerometer y axis
                 index[4] = accelerometer z axis
                 index[5] = gyroscope x axis
                 index[6] = gyroscope y axis
                 index[7] = gyroscope z axis
                 index[8] = magnetometer x axis
                 index[9] = magnetometer y axis
                 index[10] = magnetometer z axis
                 index[11] = temperature
                 index[12] = timestamp

                 If no callback was specified, then data is stored and can be
                 retrieved using mpu_9250_read_saved_data().
        &#34;&#34;&#34;
        self.mpu_read_delay = continuous_delay
        if mode == mpu_constants.MPU9250_READ_CONTINUOUS_ON:
            self._mpu9250_thread_run()
        elif mode == mpu_constants.MPU9250_READ_CONTINUOUS_OFF:
            self._mpu9250_thread_stop()
        else:
            raise RuntimeError(f&#39;Unknown mode passed to mpu_9250_read_data(). mode == {mode}&#39;)

    def _mpu_read_device(self):
        &#34;&#34;&#34;
        This is the thread code to continuously read the mpu9250
        :return:
        &#34;&#34;&#34;

        self.mpu_9250_run_event.wait()

        while True:
            mpu_data = [PrivateConstants.MPU9250, self.mpu_9250_device.address_mpu]
            if self._mpu_9250_is_running() and not self.shutdown_flag:
                mpu_data = mpu_data + self.mpu_9250_device.get_all_data()
                mpu_data.append(time.time())
                self.mpu_last_value = mpu_data
                # print(mpu_data)
                if self.mpu_callback:
                    self.mpu_callback(mpu_data)
                time.sleep(self.mpu_read_delay)
            else:
                continue

    def mpu_9250_read_saved_data(self):
        &#34;&#34;&#34;
        Retrieve and return the last data set read from the mpu_9250

        :return: last read data in list form or [] if no data is available.
        &#34;&#34;&#34;
        if self.mpu_9250_device.address_mpu:
            return self.mpu_last_value

    def pwm_write(self, pin, value):
        &#34;&#34;&#34;
        Set the selected pwm pin to the specified value.

        :param pin: PWM pin number

        :param value: Pin value (0 - 0x4000)

        &#34;&#34;&#34;
        if PrivateConstants.PWM_MESSAGE + pin &lt; 0xf0:
            command = [PrivateConstants.PWM_MESSAGE + pin, value &amp; 0x7f,
                       (value &gt;&gt; 7) &amp; 0x7f]
            self._send_command(command)
        else:
            self._pwm_write_extended(pin, value)

    def _pwm_write_extended(self, pin, data):
        &#34;&#34;&#34;
        This method will send an extended-data analog write command to the
        selected pin.

        :param pin: 0 - 127

        :param data: 0 - 0xfffff

        :returns: No return value
        &#34;&#34;&#34;
        pwm_data = [pin, data &amp; 0x7f, (data &gt;&gt; 7) &amp; 0x7f,
                    (data &gt;&gt; 14) &amp; 0x7f]
        self._send_sysex(PrivateConstants.EXTENDED_PWM, pwm_data)

    def send_reset(self):
        &#34;&#34;&#34;
        Send a Sysex reset command to the arduino

        &#34;&#34;&#34;
        try:
            self._send_command([PrivateConstants.SYSTEM_RESET])
        except RuntimeError:
            raise

    def set_pin_mode_analog_input(self, pin_number, callback=None,
                                  differential=1):
        &#34;&#34;&#34;
        Set a pin as an analog input.

        :param pin_number: arduino pin number

        :param callback: callback function

        :param differential: This value needs to be met for a callback
                             to be invoked.


        callback returns a data list:

        [pin_type, pin_number, pin_value, raw_time_stamp]

        The pin_type for analog input pins = 2

        &#34;&#34;&#34;
        self._set_pin_mode(pin_number, PrivateConstants.ANALOG,
                           callback=callback,
                           differential=differential)

    def set_pin_mode_dht(self, pin_number, sensor_type=22, differential=.1, callback=None):
        &#34;&#34;&#34;
        Configure a DHT sensor prior to operation.
        Up to 6 DHT sensors are supported

        :param pin_number: digital pin number on arduino.

        :param sensor_type: type of dht sensor
                            Valid values = DHT11, DHT12, DHT22, DHT21, AM2301

        :param differential: This value needs to be met for a callback
                             to be invoked.

        :param callback: callback function

        callback: returns a data list:

        [pin_type, pin_number, DHT type, humidity value, temperature raw_time_stamp]

        The pin_type for DHT input pins = 15

                ERROR CODES: If either humidity or temperature value:
                              == -1 Configuration Error
                              == -2 Checksum Error
                              == -3 Timeout Error
        &#34;&#34;&#34;

        # if the pin is not currently associated with a DHT device
        # initialize it.
        if pin_number not in self.dht_list:
            self.dht_list.append(pin_number)
            self.digital_pins[pin_number].cb = callback
            self.digital_pins[pin_number].current_value = [0, 0]
            self.digital_pins[pin_number].differential = differential
            data = [pin_number, sensor_type]
            self._send_sysex(PrivateConstants.DHT_CONFIG, data)
        else:
            # allow user to change the differential value
            self.digital_pins[pin_number].differential = differential

    def set_pin_mode_digital_input(self, pin_number, callback=None):
        &#34;&#34;&#34;
        Set a pin as a digital input.

        :param pin_number: arduino pin number

        :param callback: callback function


        callback returns a data list:

        [pin_type, pin_number, pin_value, raw_time_stamp]

        The pin_type for digital input pins = 0

        &#34;&#34;&#34;
        self._set_pin_mode(pin_number, PrivateConstants.INPUT, callback)

    def set_pin_mode_digital_input_pullup(self, pin_number, callback=None):
        &#34;&#34;&#34;
        Set a pin as a digital input with pullup enabled.

        :param pin_number: arduino pin number

        :param callback: callback function


        callback returns a data list:

        [pin_type, pin_number, pin_value, raw_time_stamp]

        The pin_type for digital input pins with pullups enabled = 11

        &#34;&#34;&#34;
        self._set_pin_mode(pin_number, PrivateConstants.PULLUP, callback)

    def set_pin_mode_digital_output(self, pin_number):
        &#34;&#34;&#34;
        Set a pin as a digital output pin.

        :param pin_number: arduino pin number
        &#34;&#34;&#34;

        self._set_pin_mode(pin_number, PrivateConstants.OUTPUT)

    # noinspection PyIncorrectDocstring
    def set_pin_mode_i2c(self, read_delay_time=0):
        &#34;&#34;&#34;
        Establish the standard Arduino i2c pins for i2c utilization.

        NOTE: THIS METHOD MUST BE CALLED BEFORE ANY I2C REQUEST IS MADE
        This method initializes Firmata for I2c operations.

        :param read_delay_time (in microseconds): an optional parameter,
                                                  default is 0

        NOTE: Callbacks are set within the individual i2c read methods of this
              API.
              See i2c_read, i2c_read_continuous, or i2c_read_restart_transmission.

        &#34;&#34;&#34;
        if not self.i2c_configured:
            data = [read_delay_time &amp; 0x7f, (read_delay_time &gt;&gt; 7) &amp; 0x7f]
            self._send_sysex(PrivateConstants.I2C_CONFIG, data)
            self.i2c_configured = True

    def set_pin_mode_pwm_output(self, pin_number):
        &#34;&#34;&#34;
        Set a pin as a pwm (analog output) pin.

        :param pin_number:arduino pin number

        &#34;&#34;&#34;
        self._set_pin_mode(pin_number, PrivateConstants.PWM)

    def set_pin_mode_servo(self, pin, min_pulse=544, max_pulse=2400):
        &#34;&#34;&#34;
        Configure a pin as a servo pin. Set pulse min, max in ms.

        :param pin: Servo Pin.

        :param min_pulse: Min pulse width in ms.

        :param max_pulse: Max pulse width in ms.

        &#34;&#34;&#34;
        command = [pin, min_pulse &amp; 0x7f, (min_pulse &gt;&gt; 7) &amp; 0x7f,
                   max_pulse &amp; 0x7f,
                   (max_pulse &gt;&gt; 7) &amp; 0x7f]

        self._send_sysex(PrivateConstants.SERVO_CONFIG, command)

    def set_pin_mode_sonar(self, trigger_pin, echo_pin,
                           callback=None, timeout=80000):
        &#34;&#34;&#34;
        This is a FirmataExpress feature.

        Configure the pins,ping interval and maximum distance for an HC-SR04
        type device.

        Up to a maximum of 6 SONAR devices is supported.
        If the maximum is exceeded a message is sent to the console and the
        request is ignored.

        NOTE: data is measured in centimeters. Callback is called only when the
              the latest value received is different than the previous.

        :param trigger_pin: The pin number of for the trigger (transmitter).

        :param echo_pin: The pin number for the received echo.

        :param callback: optional callback function to report sonar data changes

        :param timeout: a tuning parameter. 80000UL equals 80ms.


        callback returns a data list:

        [pin_type, trigger_pin_number, distance_value (in cm), raw_time_stamp]

        The pin_type for sonar pins = 12


        &#34;&#34;&#34;
        # if there is an entry for the trigger pin in existence,
        # ignore the duplicate request.
        if trigger_pin in self.active_sonar_map:
            return

        timeout_lsb = timeout &amp; 0x7f
        timeout_msb = (timeout &gt;&gt; 7) &amp; 0x7f
        data = [trigger_pin, echo_pin, timeout_lsb,
                timeout_msb]

        self._set_pin_mode(trigger_pin, PrivateConstants.SONAR,
                           PrivateConstants.INPUT)
        self._set_pin_mode(echo_pin, PrivateConstants.SONAR,
                           PrivateConstants.INPUT)
        # update the ping data map for this pin
        if len(self.active_sonar_map) &gt; 6:
            print(&#39;sonar_config: maximum number of devices assigned&#39;
                  &#39; - ignoring request&#39;)
        else:
            # initialize map entry with callback, data value of 0 and time_stamp of 0
            self.active_sonar_map[trigger_pin] = [callback, 0, 0]

        self._send_sysex(PrivateConstants.SONAR_CONFIG, data)

    def _set_pin_mode(self, pin_number, pin_state, callback=None,
                      differential=1):
        &#34;&#34;&#34;
        A private method to set the various pin modes.

        :param pin_number: arduino pin number

        :param pin_state: INPUT/OUTPUT/ANALOG/PWM/PULLUP
                         For SERVO use: set_pin_mode_servo
                         For DHT   use: set_pin_mode_dht

        :param callback: A reference to a call back function to be
                         called when pin data value changes

        :param differential: This value needs to be met for a callback
                             to be invoked

        &#34;&#34;&#34;
        if callback:
            if pin_state == PrivateConstants.INPUT:
                self.digital_pins[pin_number].cb = callback
            elif pin_state == PrivateConstants.PULLUP:
                self.digital_pins[pin_number].cb = callback
                self.digital_pins[pin_number].pull_up = True
            elif pin_state == PrivateConstants.ANALOG:
                self.analog_pins[pin_number].cb = callback
                self.analog_pins[pin_number].differential = differential
            else:
                print(&#39;{} {}&#39;.format(&#39;set_pin_mode: callback ignored for &#39;
                                     &#39;pin state:&#39;, pin_state))

        pin_mode = pin_state

        if pin_mode == PrivateConstants.ANALOG:
            pin_number = pin_number + self.first_analog_pin

        command = [PrivateConstants.SET_PIN_MODE, pin_number, pin_mode]
        self._send_command(command)

        if pin_state == PrivateConstants.INPUT or pin_state == PrivateConstants.PULLUP:
            self.enable_digital_reporting(pin_number)
        else:
            pass

    def set_sampling_interval(self, interval):
        &#34;&#34;&#34;
        This method sends the desired sampling interval to Firmata.

        Note: Standard Firmata  will ignore any interval less than
              10 milliseconds

        :param interval: Integer value for desired sampling interval
                         in milliseconds

        &#34;&#34;&#34;
        data = [interval &amp; 0x7f, (interval &gt;&gt; 7) &amp; 0x7f]
        self._send_sysex(PrivateConstants.SAMPLING_INTERVAL, data)

    def servo_write(self, pin, position):
        &#34;&#34;&#34;
        This is an alias for analog_write to set
        the position of a servo that has been
        previously configured using set_pin_mode_servo.

        :param pin: arduino pin number

        :param position: servo position

        &#34;&#34;&#34;

        self.pwm_write(pin, position)

    # noinspection PyBroadException
    def shutdown(self):
        &#34;&#34;&#34;
        This method attempts an orderly shutdown
        If any exceptions are thrown, they are ignored.

        &#34;&#34;&#34;

        self.shutdown_flag = True

        self._stop_threads()

        try:
            # stop all reporting - both analog and digital
            for pin in range(len(self.analog_pins)):
                self.disable_analog_reporting(pin)

            for pin in range(len(self.digital_pins)):
                self.disable_digital_reporting(pin)
            self.send_reset()
            if self.ip_address:
                try:
                    self.sock.shutdown(socket.SHUT_RDWR)
                    self.sock.close()
                except Exception:
                    pass
            else:
                self.serial_port.reset_input_buffer()
                self.serial_port.close()

        except (RuntimeError, SerialException, OSError):
            # ignore error on shutdown
            pass

    def sonar_read(self, trigger_pin):
        &#34;&#34;&#34;
        This is a FirmataExpress feature

        Retrieve Ping (HC-SR04 type) data. The data is presented as a
        dictionary.

        The &#39;key&#39; is the trigger pin specified in sonar_config()
        and the &#39;data&#39; is the current measured distance (in centimeters)
        for that pin. If there is no data, the value is set to None.

        :param trigger_pin: key into sonar data map

        :returns: A list = [last value, raw time_stamp]

        &#34;&#34;&#34;

        sonar_pin_entry = self.active_sonar_map.get(trigger_pin)
        if sonar_pin_entry:
            return [sonar_pin_entry[1], sonar_pin_entry[2]]
        else:
            return [0, 0]

    &#39;&#39;&#39;
    Firmata message handlers
    &#39;&#39;&#39;

    def _analog_mapping_response(self, data):
        &#34;&#34;&#34;
        This is a private message handler method.
        It is a message handler for the analog mapping response message.

        :param data: response data

        &#34;&#34;&#34;
        self.query_reply_data[PrivateConstants.ANALOG_MAPPING_RESPONSE] = data

    def _analog_message(self, data):
        &#34;&#34;&#34;
        This is a private message handler method.
        It is a message handler for analog messages.

        :param data: message data

        &#34;&#34;&#34;
        pin = data[0]
        value = (data[PrivateConstants.MSB] &lt;&lt; 7) + data[PrivateConstants.LSB]

        # only report when there is a change in value
        differential = abs(value - self.analog_pins[pin].current_value)
        if differential &gt;= self.analog_pins[pin].differential:
            self.analog_pins[pin].current_value = value
            time_stamp = time.time()
            self.analog_pins[pin].event_time = time_stamp

            # append pin number, pin value, and pin type to return value and return as a list
            message = [PrivateConstants.ANALOG, pin, value, time_stamp]

            if self.analog_pins[pin].cb:
                self.analog_pins[pin].cb(message)

    def _capability_response(self, data):
        &#34;&#34;&#34;
        This is a private message handler method.
        It is a message handler for capability report responses.

        :param data: capability report

        &#34;&#34;&#34;
        self.query_reply_data[PrivateConstants.CAPABILITY_RESPONSE] = data

    def _dht_read_response(self, data):
        &#34;&#34;&#34;
        Process the dht response message.

        Values are calculated using:
                humidity = (_bits[0] * 256 + _bits[1]) * 0.1

                temperature = ((_bits[2] &amp; 0x7F) * 256 + _bits[3]) * 0.1

        error codes:
        0 - OK
        1 - DHTLIB_ERROR_TIMEOUT
        2 - Checksum error

        :param: data - array of 9 7bit bytes ending with the error status
        &#34;&#34;&#34;
        # get the time of the report
        time_stamp = time.time()
        # initiate a list for a potential call back
        reply_data = [PrivateConstants.DHT]

        # get the pin and type of the dht
        pin = data[0]
        reply_data.append(pin)
        dht_type = data[1]
        reply_data.append(dht_type)
        humidity = None
        temperature = None

        self.digital_pins[pin].event_time = time_stamp

        if data[7] == 1:  # data[9] is config flag
            if data[10] != 0:
                self.dht_sensor_error = True
                humidity = temperature = -1
                # return
        else:
            # if data read correctly process and return

            if data[6] == 0:
                # dht 22
                if data[1] == 22:
                    humidity = (data[2] * 256 + data[3]) * 0.1
                    temperature = ((data[4] &amp; 0x7F) * 256 + data[5]) * 0.1
                # dht 11
                elif data[1] == 11:
                    humidity = (data[2]) + (data[3]) * 0.1
                    temperature = (data[4]) + (data[5]) * 0.1
                else:
                    raise RuntimeError(f&#39;Unknown DHT Sensor type reported: {data[2]}&#39;)

                humidity = round(humidity, 2)
                temperature = round(temperature, 2)

                # check for negative temperature
                if data[6] &amp; 0x80:
                    temperature = -temperature

            elif data[7] == 1:
                # Checksum Error
                humidity = temperature = -2
                self.dht_sensor_error = True
            elif data[7] == 2:
                # Timeout Error
                humidity = temperature = -3
                self.dht_sensor_error = True
        # since we initialize
        if humidity is None:
            return
        reply_data.append(humidity)
        reply_data.append(temperature)
        reply_data.append(time_stamp)

        # retrieve the last reported values
        last_value = self.digital_pins[pin].current_value

        self.digital_pins[pin].current_value = [humidity, temperature]
        if self.digital_pins[pin].cb:
            # only report changes
            # has the humidity changed?
            if last_value[0] != humidity:

                differential = abs(humidity - last_value[0])
                if differential &gt;= self.digital_pins[pin].differential:
                    self.digital_pins[pin].cb(reply_data)
                return
            if last_value[1] != temperature:
                differential = abs(temperature - last_value[1])
                if differential &gt;= self.digital_pins[pin].differential:
                    self.digital_pins[pin].cb(reply_data)
                return

    def _digital_message(self, data):
        &#34;&#34;&#34;
        This is a private message handler method.
        It is a message handler for Digital Messages.

        :param data: digital message

        &#34;&#34;&#34;
        port = data[0]
        # noinspection PyPep8
        port_data = (data[PrivateConstants.MSB] &lt;&lt; 7) + data[PrivateConstants.LSB]
        pin = port * 8
        for pin in range(pin, min(pin + 8, len(self.digital_pins))):
            # get pin value
            value = port_data &amp; 0x01

            # retrieve previous value
            last_value = self.digital_pins[pin].current_value

            # set the current value in the pin structure
            self.digital_pins[pin].current_value = value
            time_stamp = time.time()
            self.digital_pins[pin].event_time = time_stamp

            # append pin number, pin value, and pin type to return value and return as a list
            if self.digital_pins[pin].pull_up:
                message = [PrivateConstants.PULLUP, pin, value, time_stamp]
            else:
                message = [PrivateConstants.INPUT, pin, value, time_stamp]

            if last_value != value:
                if self.digital_pins[pin].cb:
                    self.digital_pins[pin].cb(message)

            port_data &gt;&gt;= 1

    # noinspection PyDictCreation

    def _i2c_reply(self, data):
        &#34;&#34;&#34;
        This is a private message handler method.
        It handles replies to i2c_read requests. It stores the data
        for each i2c device address in a dictionary called i2c_map.
        The data may be retrieved via a polling call to i2c_get_read_data().
        It a callback was specified in pymata.i2c_read, the raw data is sent
        through the callback

        :param data: raw data returned from i2c device

        &#34;&#34;&#34;
        # initialize the reply data with I2C pin mode
        reply_data = [PrivateConstants.I2C]
        # reassemble the data from the firmata 2 byte format
        address = (data[0] &amp; 0x7f) + (data[1] &lt;&lt; 7)

        # if we have an entry in the i2c_map, proceed
        if address in self.i2c_map:
            with self.the_i2c_map_lock:
                # get 2 bytes, combine them and append to reply data list
                for i in range(0, len(data), 2):
                    combined_data = (data[i] &amp; 0x7f) + (data[i + 1] &lt;&lt; 7)
                    reply_data.append(combined_data)

                current_time = time.time()
                reply_data.append(current_time)

                # place the data in the i2c map without storing the address byte or
                #  register byte (returned data only)
                map_entry = self.i2c_map.get(address)
                map_entry[&#39;value&#39;] = reply_data[3:]
                map_entry[&#39;time_stamp&#39;] = current_time
                self.i2c_map[address] = map_entry
                cb = map_entry.get(&#39;callback&#39;)
                if cb:
                    # send everything, including address and register bytes back
                    # to caller
                    # reply data will contain:
                    # [pin_type = 6, i2c_device address,
                    #                       raw data returned from i2c device, time-stamp]
                    cb(reply_data)

    def _pin_state_response(self, data):
        &#34;&#34;&#34;
        This is a private message handler method.
        It handles pin state query response messages.

        :param data: Pin state message

        &#34;&#34;&#34;
        self.query_reply_data[PrivateConstants.PIN_STATE_RESPONSE] = data

    def _report_firmware(self, sysex_data):
        &#34;&#34;&#34;
        This is a private message handler method.

        This method handles the sysex &#39;report firmware&#39; command sent by
        Firmata (0x79).

        It assembles the firmware version by concatenating the major and
        minor version number components and the firmware identifier into
        a string.

        e.g. &#34;2.3 StandardFirmata.ino&#34;

        :param sysex_data: Sysex data sent from Firmata

        &#34;&#34;&#34;
        # first byte after command is major number
        major = sysex_data[0]
        version_string = str(major)

        # next byte is minor number
        # minor = sysex_data[2]
        minor = sysex_data[1]

        # append a dot to major number
        version_string += &#39;.&#39;

        # append minor number
        version_string += str(minor)
        # add a space after the major and minor numbers
        version_string += &#39; &#39;

        # slice the identifier - from the first byte after the minor
        #  number up until, but not including the END_SYSEX byte

        # name = sysex_data[3:-1]
        name = sysex_data[2:]

        firmware_name_iterator = iter(name)

        # convert each element from two 7-bit bytes into characters, then add each
        # character to the version string
        for e in firmware_name_iterator:
            version_string += chr(e + (next(firmware_name_iterator) &lt;&lt; 7))

        # store the value
        self.query_reply_data[PrivateConstants.REPORT_FIRMWARE] = version_string

    def _report_version(self, data):
        &#34;&#34;&#34;
        This is a private message handler method.

        This method reads the following 2 bytes after the report version
        command (0xF9 - non sysex).

        The first byte is the major number and the second byte is the
        minor number.

        &#34;&#34;&#34;
        version_string = str(data[0]) + &#39;.&#39; + str(data[1])
        self.query_reply_data[PrivateConstants.REPORT_VERSION] = version_string

    def _send_command(self, command):
        &#34;&#34;&#34;
        This is a private utility method.
        The method sends a non-sysex command to Firmata.

        :param command:  command data

        :returns: number of bytes sent
        &#34;&#34;&#34;
        # send_message = &#34;&#34;
        send_message = bytes(command)
        if not self.ip_address:
            try:
                result = self.serial_port.write(send_message)
            except SerialException:
                if self.shutdown_on_exception:
                    self.shutdown()
                raise RuntimeError(&#39;write fail in _send_command&#39;)
            return result
        else:
            self.sock.sendall(send_message)

    def _sonar_data(self, data):
        &#34;&#34;&#34;
        This method handles the incoming sonar data message and stores
        the data in the response table.

        :param data: Message data from Firmata

        &#34;&#34;&#34;

        pin_number = data[0]
        val = int((data[PrivateConstants.MSB] &lt;&lt; 7) +
                  data[PrivateConstants.LSB])
        # initialize reply_data with SONAR pin type
        reply_data = [PrivateConstants.SONAR]

        with self.the_sonar_map_lock:
            sonar_pin_entry = self.active_sonar_map[pin_number]
            if sonar_pin_entry[0] is not None:
                # check if value changed since last reading
                if sonar_pin_entry[1] != val:
                    sonar_pin_entry[1] = val
                    time_stamp = time.time()
                    sonar_pin_entry[2] = time_stamp
                    self.active_sonar_map[pin_number] = sonar_pin_entry
                    # Do a callback if one is specified in the table
                    if sonar_pin_entry[0]:
                        reply_data.append(pin_number)
                        reply_data.append(val)
                        reply_data.append(time_stamp)
                        if sonar_pin_entry[1]:
                            sonar_pin_entry[0](reply_data)

                # update the data in the table with latest value
                else:
                    sonar_pin_entry[1] = val
                    self.active_sonar_map[pin_number] = sonar_pin_entry
            time.sleep(self.sleep_tune)

    def _send_sysex(self, sysex_command, sysex_data=None):
        &#34;&#34;&#34;
        This is a private utility method.
        This method sends a sysex command to Firmata.

        :param sysex_command: sysex command

        :param sysex_data: data for command

        &#34;&#34;&#34;
        if not sysex_data:
            sysex_data = []

        the_command = [PrivateConstants.START_SYSEX, sysex_command]
        if sysex_data:
            for d in sysex_data:
                the_command.append(d)
        the_command.append(PrivateConstants.END_SYSEX)
        with self.the_send_sysex_lock:
            self._send_command(the_command)

    # noinspection PyMethodMayBeStatic
    def _string_data(self, data):
        &#34;&#34;&#34;
        This is a private message handler method.
        It is the message handler for String data messages that will be
        printed to the console.

        :param data:  message

        &#34;&#34;&#34;
        reply = &#39;&#39;
        for x in data:
            reply_data = x
            if reply_data:
                reply += chr(reply_data)
        print(reply)

    def _run_threads(self):
        self.run_event.set()

    def _is_running(self):
        return self.run_event.is_set()

    def _mpu9250_thread_run(self):
        self.mpu_9250_run_event.set()

    def _mpu9250_thread_stop(self):
        self.mpu_9250_run_event.clear()

    def _mpu_9250_is_running(self):
        return self.mpu_9250_run_event.is_set()

    def _stop_threads(self):
        self.run_event.clear()
        self.mpu_9250_run_event.clear()

    def _reporter(self):
        &#34;&#34;&#34;
        This is the reporter thread. It continuously pulls data from
        the deque. When a full message is detected, that message is
        processed.
        &#34;&#34;&#34;
        self.run_event.wait()

        # sysex commands are assembled into this list for processing
        # next_command_byte = None
        while self._is_running() and not self.shutdown_flag:
            if len(self.the_deque):

                # get next byte from the deque and process it
                data = self.the_deque.popleft()

                # this list will be populated with the received data for the command
                response_data = []

                # process sysex commands
                if data == PrivateConstants.START_SYSEX:
                    # next char is the actual sysex command
                    # wait until we can get data from the deque
                    while len(self.the_deque) == 0:
                        pass
                    sysex_command = self.the_deque.popleft()
                    # retrieve the associated command_dispatch entry for this command
                    dispatch_entry = self.report_dispatch.get(sysex_command)

                    # get a &#34;pointer&#34; to the method that will process this command
                    method = dispatch_entry[0]

                    # now get the rest of the data excluding the END_SYSEX byte
                    end_of_sysex = False
                    while not end_of_sysex:
                        # wait for more data to arrive
                        while len(self.the_deque) == 0:
                            pass
                        data = self.the_deque.popleft()
                        if data != PrivateConstants.END_SYSEX:
                            response_data.append(data)
                        else:
                            end_of_sysex = True

                            # invoke the method to process the command
                            method(response_data)
                            # go to the beginning of the loop to process the next command
                    continue

                # is this a command byte in the range of 0x80-0xff - these are the non-sysex messages

                elif 0x80 &lt;= data &lt;= 0xff:
                    # look up the method for the command in the command dispatch table
                    # for the digital reporting the command value is modified with port number
                    # the handler needs the port to properly process, so decode that from the command and
                    # place in response_data
                    if 0x90 &lt;= data &lt;= 0x9f:
                        port = data &amp; 0xf
                        response_data.append(port)
                        data = 0x90
                    # the pin number for analog data is embedded in the command so, decode it
                    elif 0xe0 &lt;= data &lt;= 0xef:
                        pin = data &amp; 0xf
                        response_data.append(pin)
                        data = 0xe0
                    else:
                        pass

                    dispatch_entry = self.report_dispatch.get(data)

                    # this calls the method retrieved from the dispatch table
                    method = dispatch_entry[0]

                    # get the number of parameters that this command provides
                    num_args = dispatch_entry[1]

                    # look at the number of args that the selected method requires
                    # now get that number of bytes to pass to the called method
                    for i in range(num_args):
                        while len(self.the_deque) == 0:
                            pass
                        data = self.the_deque.popleft()
                        response_data.append(data)
                        # go execute the command with the argument list
                    method(response_data)

                    # go to the beginning of the loop to process the next command
                    continue
            else:
                time.sleep(self.sleep_tune)

    def _serial_receiver(self):
        &#34;&#34;&#34;
        Thread to continuously check for incoming data.
        When a byte comes in, place it onto the deque.
        &#34;&#34;&#34;
        self.run_event.wait()

        while self._is_running() and not self.shutdown_flag:
            # we can get an OSError: [Errno9] Bad file descriptor when shutting down
            # just ignore it
            try:
                if self.serial_port.inWaiting():
                    c = self.serial_port.read()
                    self.the_deque.append(ord(c))
                else:
                    time.sleep(self.sleep_tune)
                    # continue
            except OSError:
                pass

    # noinspection PyBroadException
    def _tcp_receiver(self):
        &#34;&#34;&#34;
        Thread to continuously check for incoming data.
        When a byte comes in, place it onto the deque.
        &#34;&#34;&#34;
        self.run_event.wait()
        while self._is_running() and not self.shutdown_flag:
            try:
                payload = self.sock.recv(1)
                self.the_deque.append(ord(payload))
            except Exception:
                pass</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pymata_rh.pymata_rh.PymataRh"><code class="flex name class">
<span>class <span class="ident">PymataRh</span></span>
<span>(</span><span>com_port=None, baud_rate=115200, arduino_instance_id=1, arduino_wait=4, sleep_tune=1e-06, shutdown_on_exception=True, ip_address=None, ip_port=None)</span>
</code></dt>
<dd>
<div class="desc"><p>This class exposes and implements the PymataExpress Non-asyncio API.
It uses threading to accommodate concurrency.
It includes the public API methods as well as
a set of private methods.</p>
<p>If you are using the Firmata Express Arduino sketch,
and have a single Arduino connected to your computer,
then you may accept all the default values.</p>
<p>If you are using some other Firmata sketch, then
you must specify both the com_port and baudrate for
as serial connection, or ip_address and ip_port if
using StandardFirmataWifi.</p>
<p>:param com_port: e.g. COM3 or /dev/ttyACM0.</p>
<p>:param baud_rate: Match this to the Firmata sketch in use.</p>
<p>:param arduino_instance_id: If you are using the Firmata
Express sketch, match this
value to that in the sketch.</p>
<p>:param arduino_wait: Amount of time to wait for an Arduino to
fully reset itself.</p>
<p>:param sleep_tune: A tuning parameter (typically not changed by user)</p>
<p>:param shutdown_on_exception: call shutdown before raising
a RunTimeError exception, or
receiving a KeyboardInterrupt exception</p>
<p>:param ip_address: Used with StandardFirmataWifi to specify IP address of
the WiFi device</p>
<p>:param ip_port: Used with StandardFirmataWifi to specify IP port of
the WiFi device. Typically this is 3030</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PymataRh(threading.Thread):
    &#34;&#34;&#34;
    This class exposes and implements the PymataExpress Non-asyncio API.
    It uses threading to accommodate concurrency.
    It includes the public API methods as well as
    a set of private methods.

    &#34;&#34;&#34;

    # noinspection PyPep8,PyPep8,PyPep8
    def __init__(self, com_port=None, baud_rate=115200,
                 arduino_instance_id=1, arduino_wait=4,
                 sleep_tune=0.000001,
                 shutdown_on_exception=True, ip_address=None,
                 ip_port=None):
        &#34;&#34;&#34;
        If you are using the Firmata Express Arduino sketch,
        and have a single Arduino connected to your computer,
        then you may accept all the default values.

        If you are using some other Firmata sketch, then
        you must specify both the com_port and baudrate for
        as serial connection, or ip_address and ip_port if
        using StandardFirmataWifi.

        :param com_port: e.g. COM3 or /dev/ttyACM0.

        :param baud_rate: Match this to the Firmata sketch in use.

        :param arduino_instance_id: If you are using the Firmata
                                    Express sketch, match this
                                    value to that in the sketch.

        :param arduino_wait: Amount of time to wait for an Arduino to
                             fully reset itself.

        :param sleep_tune: A tuning parameter (typically not changed by user)

        :param shutdown_on_exception: call shutdown before raising
                                      a RunTimeError exception, or
                                      receiving a KeyboardInterrupt exception

        :param ip_address: Used with StandardFirmataWifi to specify IP address of
                           the WiFi device

        :param ip_port: Used with StandardFirmataWifi to specify IP port of
                           the WiFi device. Typically this is 3030

        &#34;&#34;&#34;
        self.start_time = time.time()
        # initialize threading parent
        threading.Thread.__init__(self)

        # create the threads and set them as daemons so
        # that they stop when the program is closed

        # create a thread to interpret received serial data
        self.the_reporter_thread = threading.Thread(target=self._reporter)
        self.the_reporter_thread.daemon = True

        self.ip_address = ip_address
        self.ip_port = ip_port

        # if an ip address was specified, tcp/ip will be used instead of serial
        # transfer.
        # create a thread to continuously receive data
        if self.ip_address:
            self.the_data_receive_thread = threading.Thread(target=self._tcp_receiver)
        else:
            self.the_data_receive_thread = threading.Thread(target=self._serial_receiver)

        self.the_data_receive_thread.daemon = True

        self.i2c_configured = False

        # flag to allow the reporter and receive threads to run.
        self.run_event = threading.Event()

        # instance variable
        self.ina219 = None

        # callback function
        self.ina219_callback = None

        # ina_219 values - last values retrieved
        self.ina_last_value_bus_voltage = []
        self.ina_last_value_bus_current = []
        self.ina_last_value_supply_voltage = []
        self.ina_last_value_shunt_voltage = []
        self.ina_last_value_power = []

        # mpu_9250 threading
        self.mpu_9250_thread = threading.Thread(target=self._mpu_read_device)
        self.mpu_9250_thread.daemon = True
        self.mpu_9250_device = None
        self.mpu_callback = None
        self.mpu_last_value = []
        self.mpu_constants = mpu_constants

        self.mpu_read_delay = 0.3  # delay between reads

        # flag to allow mpu_9250 to run
        self.mpu_9250_run_event = threading.Event()

        # check to make sure that Python interpreter is version 3.7 or greater
        python_version = sys.version_info
        if python_version[0] &gt;= 3:
            if python_version[1] &gt;= 7:
                pass
            else:
                raise RuntimeError(&#34;ERROR: Python 3.7 or greater is &#34;
                                   &#34;required for use of this program.&#34;)

        # save input parameters as instance variables
        self.com_port = com_port
        self.baud_rate = baud_rate
        self.arduino_instance_id = arduino_instance_id
        self.arduino_wait = arduino_wait
        self.sleep_tune = sleep_tune
        self.shutdown_on_exception = shutdown_on_exception

        # create a deque to receive and process data from the arduino
        self.the_deque = deque()

        # The report_dispatch dictionary is used to process
        # incoming report sysex message by looking up the sysex command
        # and executing its associated processing method.
        # The value following the method is the number of bytes to
        # retrieve from the deque to process the command.
        self.report_dispatch = {}

        # To add a command to the command dispatch table, append here.
        self.report_dispatch.update({PrivateConstants.REPORT_VERSION: [self._report_version, 2]})
        self.report_dispatch.update({PrivateConstants.REPORT_FIRMWARE: [self._report_firmware, 1]})
        self.report_dispatch.update({PrivateConstants.ANALOG_MESSAGE: [self._analog_message, 2]})
        self.report_dispatch.update({PrivateConstants.DIGITAL_MESSAGE: [self._digital_message, 2]})
        self.report_dispatch.update({PrivateConstants.SONAR_DATA: [self._sonar_data, 3]})
        self.report_dispatch.update({PrivateConstants.STRING_DATA: [self._string_data, 2]})
        self.report_dispatch.update({PrivateConstants.I2C_REPLY: [self._i2c_reply, 2]})
        self.report_dispatch.update({PrivateConstants.CAPABILITY_RESPONSE: [self._capability_response, 2]})
        self.report_dispatch.update({PrivateConstants.PIN_STATE_RESPONSE: [self._pin_state_response, 2]})
        self.report_dispatch.update({PrivateConstants.ANALOG_MAPPING_RESPONSE: [self._analog_mapping_response, 4]})
        self.report_dispatch.update({PrivateConstants.DHT_DATA: [self._dht_read_response, 7]})

        # report query results are stored in this dictionary
        self.query_reply_data = {PrivateConstants.REPORT_VERSION: &#39;&#39;,
                                 PrivateConstants.STRING_DATA: &#39;&#39;,
                                 PrivateConstants.REPORT_FIRMWARE: &#39;&#39;,
                                 PrivateConstants.CAPABILITY_RESPONSE: None,
                                 PrivateConstants.ANALOG_MAPPING_RESPONSE:
                                     None,
                                 PrivateConstants.PIN_STATE_RESPONSE: None}

        self.firmata_firmware = []

        # a flag to indicate if using FirmataExpress
        self.using_firmata_express = False

        # dht error flag
        self.dht_sensor_error = False

        # a list of PinData objects - one for each pin segregated by pin type
        # see pin_data.py
        self.analog_pins = []
        self.digital_pins = []

        # a list of pins assigned to DHT devices
        self.dht_list = []

        # This lock is used when the PinData object is update or contents
        # are retrieved
        self.the_pin_data_lock = threading.Lock()

        # a lock for sending i2c commands
        self.the_i2c_send_lock = threading.RLock()

        # a lock for the i2c map data structure
        self.the_i2c_map_lock = threading.Lock()

        # a lock for the sonar map
        self.the_sonar_map_lock = threading.Lock()

        # a when sending data to the arduino
        self.the_send_sysex_lock = threading.Lock()

        # serial port in use
        self.serial_port = None

        # handle to tcp/ip socket
        self.sock = None

        # An i2c_map entry consists of a device i2c address as the key, and
        #  the value of the key consists of a dictionary containing 2 entries.
        #  The first entry. &#39;value&#39; contains the last value reported, and
        # the second, &#39;callback&#39; contains a reference to a callback function,
        # and the third, a time-stamp
        # For example:
        # {12345: {&#39;value&#39;: 23, &#39;callback&#39;: None, time_stamp:None}}
        self.i2c_map = {}

        # The active_sonar_map maps the sonar trigger pin number (the key)
        # to the current data value returned
        # if a callback was specified, it is stored in the map as well.
        # A map entry consists of:
        #   pin: [callback, current_data_returned, time_stamp]
        self.active_sonar_map = {}

        # first analog pin number
        self.first_analog_pin = None

        # flag to indicate we are in shutdown mode
        self.shutdown_flag = False

        print(f&#34;pymata4:  Version {PrivateConstants.PYMATA_EXPRESS_THREADED_VERSION}\n\n&#34;
              f&#34;Copyright (c) 2020 Alan Yorinks All Rights Reserved.\n&#34;)
        # if this is not a tcp interface, find the serial port
        if not self.ip_address:
            if not self.com_port:
                # user did not specify a com_port
                try:
                    self._find_arduino()
                except KeyboardInterrupt:
                    if self.shutdown_on_exception:
                        self.shutdown()
            else:
                # com_port specified - set com_port and baud rate
                try:
                    self._manual_open()
                except KeyboardInterrupt:
                    if self.shutdown_on_exception:
                        self.shutdown()

            if self.serial_port:
                print(f&#34;Arduino compatible device found and connected to {self.serial_port.port}&#34;)

            # no com_port found - raise a runtime exception
            else:
                if self.shutdown_on_exception:
                    self.shutdown()
                raise RuntimeError(&#39;No Arduino Found or User Aborted Program&#39;)
        # this is tcp/ip interface
        else:
            # with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as self.sock:
            #     s = self.sock.create_connection((self.ip_address, self.ip_port))
            #     print(s)
            self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.sock.connect((self.ip_address, self.ip_port))
            print(f&#39;Successfully connected to: {self.ip_address}:{self.ip_port}&#39;)

        self.the_reporter_thread.start()
        self.the_data_receive_thread.start()
        self.mpu_9250_thread.start()
        # allow the threads to run
        self._run_threads()

        # get arduino firmware version and print it
        try:
            print(&#39;\nRetrieving Arduino Firmware ID...&#39;)
            firmware_version = self.get_firmware_version()

            if not firmware_version:
                if self.shutdown_on_exception:
                    self.shutdown()
                raise RuntimeError(f&#39;Firmata Sketch Firmware Version Not Found&#39;)
            else:
                if self.using_firmata_express:
                    version_number = firmware_version[0:3]
                    if version_number != PrivateConstants.FIRMATA_EXPRESS_VERSION:
                        raise RuntimeError(f&#39;You must use FirmataExpress version 1.1. Version Found = {version_number}&#39;)
                print(f&#39;Arduino Firmware ID: {firmware_version}&#39;)
        except TypeError:
            print(&#39;\nIs your serial cable plugged in and do you have the &#39;
                  &#39;correct Firmata sketch loaded?&#39;)
            print(&#39;Is the COM port correct?&#39;)
            print(&#39;To see a list of serial ports, type: &#34;list_serial_ports&#34; &#39;
                  &#39;in your console.&#39;)
            raise RuntimeError
        except KeyboardInterrupt:
            if self.shutdown_on_exception:
                self.shutdown()
            raise RuntimeError(&#39;No Arduino Found or User Aborted Program&#39;)

        print(&#39;\nRetrieving analog map...&#39;)

        # try to get an analog pin map. if it comes back as none raise an exception

        report = self.get_analog_map()
        if not report:
            if self.shutdown_on_exception:
                self.shutdown()
            raise RuntimeError(f&#39;*** Analog map retrieval timed out. ***&#39;
                               f&#39;\nDo you have Arduino connectivity and do you have the &#39;
                               f&#39;correct Firmata sketch uploaded to the board?&#39;)

        # custom assemble the pin lists
        try:
            for pin in report:
                digital_data = PinData(self.the_pin_data_lock)
                self.digital_pins.append(digital_data)
                if pin != PrivateConstants.IGNORE:
                    analog_data = PinData(self.the_pin_data_lock)
                    self.analog_pins.append(analog_data)

            print(f&#39;Auto-discovery complete. Found {len(self.digital_pins)} Digital Pins&#39;
                  f&#39; and {len(self.analog_pins)} Analog Pins\n\n&#39;)
            self.first_analog_pin = len(self.digital_pins) - len(self.analog_pins)
        except KeyboardInterrupt:
            if self.shutdown_on_exception:
                self.shutdown()
            raise RuntimeError(&#39;User Hit Control-C&#39;)

        # Set the sampling interval to the standard value
        # so the the DHT and HC-SRO4 device report at the right
        # time frame.
        self.set_sampling_interval(19)

    def _find_arduino(self):
        &#34;&#34;&#34;
        This method will search all potential serial ports for an Arduino
        containing a sketch that has a matching arduino_instance_id as
        specified in the input parameters of this class.

        This is used explicitly with the FirmataExpress sketch.
        &#34;&#34;&#34;

        # a list of serial ports to be checked
        serial_ports = []

        print(&#39;Opening all potential serial ports...&#39;)
        the_ports_list = list_ports.comports()
        for port in the_ports_list:
            if port.pid is None:
                continue
            try:
                self.serial_port = serial.Serial(port.device, self.baud_rate,
                                                 timeout=1, writeTimeout=0)
            except SerialException:
                continue
            # create a list of serial ports that we opened
            serial_ports.append(self.serial_port)

            # display to the user
            print(&#39;\t&#39; + port.device)

            # clear out any possible data in the input buffer
            self.serial_port.reset_input_buffer()
            self.serial_port.reset_output_buffer()

        # wait for arduino to reset
        print(f&#39;\nWaiting {self.arduino_wait} seconds(arduino_wait) for Arduino devices to &#39;
              &#39;reset...&#39;)
        try:
            time.sleep(self.arduino_wait)

            print(f&#39;\nSearching for an Arduino configured with an arduino_instance = {self.arduino_instance_id}&#39;)

            for serial_port in serial_ports:
                self.serial_port = serial_port
                # send the &#34;are you there&#34; sysex request to the arduino
                self._send_sysex(PrivateConstants.ARE_YOU_THERE)

                # wait until the END_SYSEX comes back
                i_am_here = self.serial_port.read_until(b&#39;\xf7&#39;)

                if not i_am_here:
                    continue

                # make sure we get back the expected length
                if len(i_am_here) != 4:
                    continue

                # convert i_am_here to a list
                i_am_here = list(i_am_here)

                # check sysex command is I_AM_HERE
                if i_am_here[1] != PrivateConstants.I_AM_HERE:
                    continue
                else:
                    # got an I am here message - is it the correct ID?
                    if i_am_here[2] == self.arduino_instance_id:
                        self.using_firmata_express = True
                        self.com_port = self.serial_port
                        return
        except KeyboardInterrupt:
            raise RuntimeError(&#39;User Hit Control-C&#39;)

    def _manual_open(self):
        &#34;&#34;&#34;
        Com port was specified by the user - try to open up that port

        &#34;&#34;&#34;
        # if port is not found, a serial exception will be thrown
        try:
            print(f&#39;Opening {self.com_port}...&#39;)
            self.serial_port = serial.Serial(self.com_port, self.baud_rate,
                                             timeout=1, writeTimeout=0)

            print(f&#39;\nWaiting {self.arduino_wait} seconds(arduino_wait) for Arduino devices to &#39;
                  &#39;reset...&#39;)
            time.sleep(self.arduino_wait)
            # time.sleep(self.arduino_wait)
            if self.baud_rate == 115200:
                self._send_sysex(PrivateConstants.ARE_YOU_THERE)

                # wait until the END_SYSEX comes back
                i_am_here = self.serial_port.read_until(b&#39;\xf7&#39;)

                # convert i_am_here to a list
                i_am_here = list(i_am_here)

                if len(i_am_here) != 4:
                    raise RuntimeError(&#39;Invalid Arduino ID reply length&#39;)

                # check sysex command is I_AM_HERE
                if i_am_here[1] != PrivateConstants.I_AM_HERE:
                    raise RuntimeError(&#39;Retrieving ID From Arduino Failed.&#39;)
                else:
                    # got an I am here message - is it the correct ID?
                    if i_am_here[2] == self.arduino_instance_id:
                        return
                    else:
                        raise RuntimeError(&#39;Invalid Arduino identifier retrieved&#39;)
        except KeyboardInterrupt:
            raise RuntimeError(&#39;User Hit Control-C&#39;)

    def analog_read(self, pin):
        &#34;&#34;&#34;
        Retrieve the last data update for the specified analog pin.

        :param pin: Analog pin number (ex. A2 is specified as 2)

        :returns: A list = [last value change,  time_stamp]
        &#34;&#34;&#34;
        return self.analog_pins[pin].current_value, self.analog_pins[pin].event_time

    def dht_read(self, pin):
        &#34;&#34;&#34;
        Retrieve the last data update for the specified dht pin.

        :param pin: digital pin number

        :return: A list = [humidity, temperature  time_stamp]

                 ERROR CODES: If either humidity or temperature value:
                              == -1 Configuration Error
                              == -2 Checksum Error
                              == -3 Timeout Error

        &#34;&#34;&#34;
        return self.digital_pins[pin].current_value[0], \
               self.digital_pins[pin].current_value[1], \
               self.digital_pins[pin].event_time

    def digital_read(self, pin):
        &#34;&#34;&#34;
        Retrieve the last data update for the specified digital pin.

        :param pin: Digital pin number

        :returns: A list = [last value change,  time_stamp]

        &#34;&#34;&#34;
        return [self.digital_pins[pin].current_value, self.digital_pins[pin].event_time]

    def digital_write(self, pin, value):
        &#34;&#34;&#34;
        Set the specified pin to the specified value.

        :param pin: arduino pin number

        :param value: pin value (1 or 0)

        &#34;&#34;&#34;
        # The command value is not a fixed value, but needs to be calculated
        # using the pin&#39;s port number
        port = pin // 8

        calculated_command = PrivateConstants.DIGITAL_MESSAGE + port
        mask = 1 &lt;&lt; (pin % 8)
        # Calculate the value for the pin&#39;s position in the port mask
        if value == 1:
            PrivateConstants.DIGITAL_OUTPUT_PORT_PINS[port] |= mask
        else:
            PrivateConstants.DIGITAL_OUTPUT_PORT_PINS[port] &amp;= ~mask

        # Assemble the command
        command = (calculated_command,
                   PrivateConstants.DIGITAL_OUTPUT_PORT_PINS[port] &amp; 0x7f,
                   (PrivateConstants.DIGITAL_OUTPUT_PORT_PINS[port] &gt;&gt; 7)
                   &amp; 0x7f)

        self._send_command(command)

    def disable_analog_reporting(self, pin):
        &#34;&#34;&#34;
        Disables analog reporting for a single analog pin.

        :param pin: Analog pin number. For example for A0, the number is 0.

        &#34;&#34;&#34;
        pin = pin + self.first_analog_pin
        self.set_pin_mode_digital_input(pin)

    def disable_digital_reporting(self, pin):
        &#34;&#34;&#34;
        Disables digital reporting. By turning reporting off for this pin,
        Reporting is disabled for all 8 bits in the &#34;port&#34;

        :param pin: Pin and all pins for this port

        &#34;&#34;&#34;
        port = pin // 8
        command = [PrivateConstants.REPORT_DIGITAL + port,
                   PrivateConstants.REPORTING_DISABLE]
        self._send_command(command)

    def enable_analog_reporting(self, pin, callback=None, differential=1):
        &#34;&#34;&#34;
        Enables analog reporting. This is an alias for set_pin_mode_analog_input.
        Disabling analog reporting sets the pin to a digital input pin,
        so we need to provide the callback and differential if we wish
        to specify it.

        :param pin: Analog pin number. For example for A0, the number is 0.

        :param callback: callback function

        :param differential: This value needs to be met for a callback
                             to be invoked.
        &#34;&#34;&#34;
        self.set_pin_mode_analog_input(pin, callback, differential)

    def enable_digital_reporting(self, pin):
        &#34;&#34;&#34;
        Enables digital reporting. By turning reporting on for all 8 bits
        in the &#34;port&#34; - this is part of Firmata&#39;s protocol specification.

        :param pin: Pin and all pins for this port

        :returns: No return value
            &#34;&#34;&#34;
        port = pin // 8
        command = [PrivateConstants.REPORT_DIGITAL + port,
                   PrivateConstants.REPORTING_ENABLE]
        self._send_command(command)

    def get_analog_map(self):
        &#34;&#34;&#34;
        This method requests a Firmata analog map query and returns the
        results.

        :returns: An analog map response or None if a timeout occurs
        &#34;&#34;&#34;
        # get the current time to make sure a report is retrieved
        current_time = time.time()

        # if we do not have existing report results, send a Firmata
        # message to request one

        self._send_sysex(PrivateConstants.ANALOG_MAPPING_QUERY)
        # wait for the report results to return for 4 seconds
        # if the timer expires, return None
        while self.query_reply_data.get(
                PrivateConstants.ANALOG_MAPPING_RESPONSE) is None:
            elapsed_time = time.time()
            if elapsed_time - current_time &gt; 4:
                return None
            # time.sleep(self.sleep_tune)
            time.sleep(.01)
        return self.query_reply_data.get(PrivateConstants.ANALOG_MAPPING_RESPONSE)

    def get_capability_report(self):
        &#34;&#34;&#34;
        This method requests and returns a Firmata capability query report

        :returns: A capability report in the form of a list
        &#34;&#34;&#34;

        self._send_sysex(PrivateConstants.CAPABILITY_QUERY)
        while self.query_reply_data.get(
                PrivateConstants.CAPABILITY_RESPONSE) is None:
            time.sleep(self.sleep_tune)
        return self.query_reply_data.get(PrivateConstants.CAPABILITY_RESPONSE)

    def get_firmware_version(self):
        &#34;&#34;&#34;
        This method retrieves the Firmata firmware version

        :returns: Firmata firmware version
        &#34;&#34;&#34;
        self._send_sysex(PrivateConstants.REPORT_FIRMWARE)

        current_time = time.time()
        while self.query_reply_data.get(PrivateConstants.REPORT_FIRMWARE) == &#39;&#39;:
            elapsed_time = time.time()
            if elapsed_time - current_time &gt; 4:
                return None
            time.sleep(self.sleep_tune)
        return self.query_reply_data.get(PrivateConstants.REPORT_FIRMWARE)

    def get_protocol_version(self):
        &#34;&#34;&#34;
        This method returns the major and minor values for the protocol
        version, i.e. 2.5

        :returns: Firmata protocol version
        &#34;&#34;&#34;
        self._send_command([PrivateConstants.REPORT_VERSION])
        while self.query_reply_data.get(
                PrivateConstants.REPORT_VERSION) == &#39;&#39;:
            time.sleep(self.sleep_tune)
        # v_major =
        return self.query_reply_data.get(PrivateConstants.REPORT_VERSION)

    def get_pin_state(self, pin):
        &#34;&#34;&#34;
        This method retrieves a pin state report for the specified pin.
        Pin modes reported:

        INPUT   = 0x00  # digital input mode

        OUTPUT  = 0x01  # digital output mode

        ANALOG  = 0x02  # analog input mode

        PWM     = 0x03  # digital pin in PWM output mode

        SERVO   = 0x04  # digital pin in Servo output mode

        I2C     = 0x06  # pin included in I2C setup

        STEPPER = 0x08  # digital pin in stepper mode

        PULLUP  = 0x0b  # digital pin in input pullup mode

        SONAR   = 0x0c  # digital pin in SONAR mode

        TONE    = 0x0d  # digital pin in tone mode

        :param pin: Pin of interest

        :returns: pin state report

        &#34;&#34;&#34;
        # place pin in a list to keep _send_sysex happy
        self._send_sysex(PrivateConstants.PIN_STATE_QUERY, [pin])
        while self.query_reply_data.get(
                PrivateConstants.PIN_STATE_RESPONSE) is None:
            time.sleep(self.sleep_tune)
        pin_state_report = self.query_reply_data.get(
            PrivateConstants.PIN_STATE_RESPONSE)
        self.query_reply_data[PrivateConstants.PIN_STATE_RESPONSE] = None
        return pin_state_report

    # noinspection PyMethodMayBeStatic
    def get_pymata_version(self):
        &#34;&#34;&#34;
        This method retrieves the PyMata Express version number

        :returns: PyMata Express version number.
        &#34;&#34;&#34;
        return PrivateConstants.PYMATA_EXPRESS_THREADED_VERSION

    def i2c_read_saved_data(self, address):
        &#34;&#34;&#34;
        This method retrieves cached i2c data to support a polling mode.

        :param address: I2C device address

        :returns data: [raw data returned from i2c device, time-stamp]

        &#34;&#34;&#34;
        if address in self.i2c_map:
            with self.the_i2c_map_lock:
                map_entry = self.i2c_map.get(address)
                return map_entry.get(&#39;value&#39;)
        else:
            return None

    def i2c_read(self, address, register, number_of_bytes,
                 callback=None):
        &#34;&#34;&#34;
        Read the specified number of bytes from the specified register for
        the i2c device.


        :param address: i2c device address

        :param register: i2c register (or None if no register selection is needed)

        :param number_of_bytes: number of bytes to be read

        :param callback: Optional callback function to report i2c data as a
                   result of read command


        callback returns a data list:

        [pin_type, i2c_device_address, i2c_read_register, data_bytes returned, time_stamp]

        The pin_type for i2c = 6

        &#34;&#34;&#34;
        with self.the_i2c_send_lock:
            self._i2c_read_request(address, register, number_of_bytes,
                                   PrivateConstants.I2C_READ, callback)

    def i2c_read_continuous(self, address, register, number_of_bytes,
                            callback=None):
        &#34;&#34;&#34;
        Some i2c devices support a continuous streaming data output.
        This command enables that mode for the device that supports
        continuous reads.


        :param address: i2c device address

        :param register: i2c register (or None if no register selection is needed)

        :param number_of_bytes: number of bytes to be read

        :param callback: Optional callback function to report i2c data as a
                   result of read command


        callback returns a data list:

        [pin_type, i2c_device_address, i2c_read_register, data_bytes returned, time_stamp]

        The pin_type for i2c = 6


        &#34;&#34;&#34;
        with self.the_i2c_send_lock:
            self._i2c_read_request(address, register, number_of_bytes,
                                   PrivateConstants.I2C_READ_CONTINUOUSLY,
                                   callback)

    def i2c_read_restart_transmission(self, address, register,
                                      number_of_bytes,
                                      callback=None):
        &#34;&#34;&#34;
        Read the specified number of bytes from the specified register for
        the i2c device. This restarts the transmission after the read. It is
        required for some i2c devices such as the MMA8452Q accelerometer.


        :param address: i2c device address

        :param register: i2c register (or None if no register
                                                    selection is needed)

        :param number_of_bytes: number of bytes to be read

        :param callback: Optional callback function to report i2c data as a
                   result of read command


        callback returns a data list:

        [pin_type, i2c_device_address, i2c_read_register, data_bytes returned, time_stamp]

        The pin_type for i2c pins = 6

        &#34;&#34;&#34;
        with self.the_i2c_send_lock:
            self._i2c_read_request(address, register, number_of_bytes,
                                   PrivateConstants.I2C_READ
                                   | PrivateConstants.I2C_END_TX_MASK,
                                   callback)

    def _i2c_read_request(self, address, register, number_of_bytes, read_type,
                          callback=None):
        &#34;&#34;&#34;
        This method requests the read of an i2c device. Results are retrieved
        by a call to i2c_get_read_data(). or by callback.

        If a callback method is provided, when data is received from the
        device it will be sent to the callback method.

        Some devices require that transmission be restarted
        (e.g. MMA8452Q accelerometer).

        I2C_READ | I2C_END_TX_MASK values for the read_type in those cases.

        I2C_READ = 0B00001000

        I2C_READ_CONTINUOUSLY = 0B00010000

        I2C_STOP_READING = 0B00011000

        I2C_END_TX_MASK = 0B01000000

        :param address: i2c device address

        :param register: register number (or None if no register selection is needed)

        :param number_of_bytes: number of bytes expected to be returned

        :param read_type: I2C_READ  or I2C_READ_CONTINUOUSLY. I2C_END_TX_MASK
                          may be OR&#39;ed when required

        :param callback: Optional callback function to report i2c data as a
                   result of read command

        &#34;&#34;&#34;
        with self.the_i2c_send_lock:
            if address not in self.i2c_map:
                with self.the_i2c_map_lock:
                    self.i2c_map[address] = {&#39;value&#39;: None, &#39;callback&#39;: callback}
            if register is not None:
                data = [address, read_type, register &amp; 0x7f, (register &gt;&gt; 7) &amp; 0x7f,
                        number_of_bytes &amp; 0x7f, (number_of_bytes &gt;&gt; 7) &amp; 0x7f]
            else:
                data = [address, read_type,
                        number_of_bytes &amp; 0x7f, (number_of_bytes &gt;&gt; 7) &amp; 0x7f]
            self._send_sysex(PrivateConstants.I2C_REQUEST, data)

    def i2c_write(self, address, args):
        &#34;&#34;&#34;
        Write data to an i2c device.

        :param address: i2c device address

        :param args: A variable number of bytes to be sent to the device
                     passed in as a list

        &#34;&#34;&#34;
        with self.the_i2c_send_lock:
            data = [address, PrivateConstants.I2C_WRITE]
            for item in args:
                item_lsb = item &amp; 0x7f
                data.append(item_lsb)
                item_msb = (item &gt;&gt; 7) &amp; 0x7f
                data.append(item_msb)
            self._send_sysex(PrivateConstants.I2C_REQUEST, data)

    def ina_initialize(self, address=0x40, shunt_ohms=0.2,
                       max_expected_amps=0.2, callback=None):
        &#34;&#34;&#34;
        This method instantiates an INA219 object.

        :param address: The i2c address of the device

        :param shunt_ohms: The shunt resistance in ohms

        :param max_expected_amps: The maximum expected current in amps

        :param callback: Callback method that will INA219 callbacks

        Note: There is a single callback shared by all INA methods.

        &#34;&#34;&#34;
        # make sure that we initialize i2c mode
        self.set_pin_mode_i2c()

        # instantiate ina_219 and save callback
        self.ina219 = INA219(self, shunt_ohms, max_expected_amps, address)
        self.ina219.configure(self.ina219.RANGE_16V, self.ina219.GAIN_AUTO)
        self.ina219_callback = callback

    def ina_read_bus_voltage(self):
        &#34;&#34;&#34;
        This method well execute a read of the bus voltage.
        If a callback was specified in ina_initialize, then
        a callback frame is specified as follows:

        [pin_type=0x11, device_i2c_address, read_type=0 (bus voltage), voltage, units=&#39;V&#39;, timestamp]

        The data is also saved to be retrieved by ina_read_supply_voltage_last()

        :return: callback is called and storage updated with latest value
        &#34;&#34;&#34;
        # noinspection PyProtectedMember
        self.ina219.voltage()

    def ina_read_bus_voltage_last(self):
        &#34;&#34;&#34;
        Retrieve last bus voltage value read from the ina_219.

        :return: list: [pin_type=0x11, device_i2c_address, read_type=0 (bus voltage), units=&#39;V&#39;, timestamp]
        &#34;&#34;&#34;
        return self.ina_last_value_bus_voltage

    def ina_read_bus_current(self):
        &#34;&#34;&#34;
        This method well execute a read of the bus current.
        If a callback was specified in ina_initialize, then
        a callback frame is specified as follows:

        [pin_type=0x11, device_i2c_address, read_type=1 (bus current), current, units=&#39;mA&#39;, timestamp]

        The data is also saved to be retrieved by ina_read_bus_current_last()

        :return: callback is called and storage updated with latest value
        &#34;&#34;&#34;
        # noinspection PyProtectedMember
        self.ina219.current()

    def ina_read_bus_current_last(self):
        &#34;&#34;&#34;
        Retrieve last supply voltage value read from the ina_219.


        :return: list:

        [pin_type=0x11, device_i2c_address, read_type=1 (bus voltage), voltage, units=&#39;mA&#39;, timestamp]
        &#34;&#34;&#34;
        return self.ina_last_value_bus_current

    def ina_read_supply_voltage(self):
        &#34;&#34;&#34;
        This method well execute a read of the supply voltage.
        If a callback was specified in ina_initialize, then
        a callback frame is specified as follows:

        [pin_type=0x11, device_i2c_address, read_type=2 (supply voltage), supply voltage, unit=&#39;V&#39;,timestamp]

        The data is also saved to be retrieved by ina_read_supply_voltage_last()

        :return: callback is called and storage updated with latest value
        &#34;&#34;&#34;
        # noinspection PyProtectedMember
        self.ina219.supply_voltage()

    def ina_read_supply_voltage_last(self):
        &#34;&#34;&#34;
        This method retrieves the last supply voltage read.

        :return: list:

        [pin_type=0x11, device_i2c_address, read_type=2 (supply voltage), voltage, units=&#39;V&#39;, timestamp]

        &#34;&#34;&#34;
        return self.ina_last_value_supply_voltage

    def ina_read_shunt_voltage(self):
        &#34;&#34;&#34;
        This method well execute a read of the shunt voltage.
        If a callback was specified in ina_initialize, then
        a callback frame is specified as follows:

        [pin_type=0x11, device_i2c_address, read_type=3 (supply voltage), shunt voltage, units=&#39;mV&#39;, timestamp]

        The data is also saved to be retrieved by ina_read_shunt_voltage_last()

        :return: callback is called and storage updated with latest value
        &#34;&#34;&#34;
        # noinspection PyProtectedMember
        self.ina219.shunt_voltage()

    def ina_read_shunt_voltage_last(self):
        &#34;&#34;&#34;
        This method well execute a read of the shunt voltage.
        If a callback was specified in ina_initialize, then
        a callback frame is specified as follows:


        :return: list:
        [pin_type=0x11, device_i2c_address, read_type=3 (shunt voltage), shunt voltage, units=&#39;mV&#39;, timestamp]
        &#34;&#34;&#34;

        # noinspection PyProtectedMember
        return self.ina_last_value_shunt_voltage

    def ina_read_power(self):
        &#34;&#34;&#34;
        This method well execute a read of the power.
        If a callback was specified in ina_initialize, then
        a callback frame is specified as follows:

        [pin_type=0x11, device_i2c_address, read_type=4 (power), power, units=&#39;mW&#39;, timestamp]

        The data is also saved to be retrieved by ina_read_power_last()

        :return: callback is called and storage updated with latest value
        &#34;&#34;&#34;
        # noinspection PyProtectedMember
        self.ina219.power()

    def ina_read_power_last(self):
        &#34;&#34;&#34;
        This method retrieves the last read power value.

        :return: list:
                [pin_type=0x11, device_i2c_address, read_type=4 (power), power, units=&#39;mW&#39;, timestamp]

        &#34;&#34;&#34;

        # noinspection PyProtectedMember
        return self.ina_last_value_power

    def ina_sleep(self):
        self.ina219.ina_sleep()

    def ina_wake(self):
        self.ina219.ina_wake()

    def mpu_9250_calibrate(self, log=True):
        &#34;&#34;&#34;
        This method will calibrate the device. This is a lengthy process
        and may take about a minute to complete.

        This method will:
        1. Test if the mpu_9250 was initialized and if not, it will
           initialize with the default values.
        2. Print the current device settings.
        3. Run the calibrations for both the calibrate_ak8963 and MPU6050.
        4. Configure the device with the new settings.
        5. Print the new device settings.

        :param: logging - If set to true calibration data is logged to a file
                          named mpu_calibration.log

        :return: If an error is encountered a RunTimeError exception is raised.
        &#34;&#34;&#34;
        if logging:
            logging.basicConfig(filename=&#39;mpu_calibration.log&#39;, filemode=&#39;a&#39;, level=logging.DEBUG)
            print(&#39;Configuration data being logged to mpu_calibration.log&#39;)

        if not self.mpu_9250_device:
            print(&#39;Initializing mpu9250&#39;)
            self.mpu_9250_initialize()
        print(&#39;Settings Before Calibration:&#39;)
        if log:
            logging.info(&#39;&#39;)
            logging.info(f&#39;Calibration Date: {datetime.datetime.now()}&#39;)
            logging.info(&#39;Settings Before Calibration:&#39;)

        print()
        if log:
            self._mpu_9250_get_current_settings(log=True)
        else:
            self._mpu_9250_get_current_settings(log=False)
        print()
        print(&#39;Calibrating ...&#39;)
        print()
        self.mpu_9250_device.calibrate()

        print(&#39;Configuring with calibrated values...&#39;)
        print()
        self.mpu_9250_device.configure()
        print()

        print(&#39;Settings After Calibration:&#39;)
        if log:
            logging.info(&#39;Settings After Calibration:&#39;)
        print()
        if log:
            self._mpu_9250_get_current_settings(log=True)
        else:
            self._mpu_9250_get_current_settings(log=False)

        print()

    def _mpu_9250_get_current_settings(self, log):
        &#34;&#34;&#34;
        Retrieve and print the current mpu9250 settings

        :return: Settings are printed to console
        &#34;&#34;&#34;
        settings = self.mpu_9250_device.get_all_settings()
        print(f&#39;MPU Address: {settings[0]}&#39;)
        print(f&#39;AK Address: {settings[1]}&#39;)
        print(f&#39;Accel Resolution: {settings[3]}&#39;)
        print(f&#39;Gyro Resolution: {settings[2]}&#39;)
        print(f&#39;Mag Resolution: {settings[4]}&#39;)
        print(f&#39;Accel Bias: {tuple(settings[8:11])}&#39;)
        print(f&#39;Gyro Bias: {tuple(settings[5:8])}&#39;)
        print(f&#39;Mag Bias: {tuple(settings[17:20])}&#39;)
        print(f&#39;Mag Calibration: {tuple(settings[11:14])}&#39;)
        print(f&#39;Mag Scale: {tuple(settings[14:17])}&#39;)

        if log:
            logging.info(f&#39;MPU Address: {settings[0]}&#39;)
            logging.info(f&#39;AK Address: {settings[1]}&#39;)
            logging.info(f&#39;Accel Resolution: {settings[3]}&#39;)
            logging.info(f&#39;Gyro Resolution: {settings[2]}&#39;)
            logging.info(f&#39;Mag Resolution: {settings[4]}&#39;)
            logging.info(f&#39;Accel Bias: {tuple(settings[8:11])}&#39;)
            logging.info(f&#39;Gyro Bias: {tuple(settings[5:8])}&#39;)
            logging.info(f&#39;Mag Bias: {tuple(settings[17:20])}&#39;)
            logging.info(f&#39;Mag Calibration: {tuple(settings[11:14])}&#39;)
            logging.info(f&#39;Mag Scale: {tuple(settings[14:17])}&#39;)

    def mpu_9250_initialize(self, address_ak=mpu_constants.AK8963_ADDRESS,
                            address_mpu=mpu_constants.MPU9250_ADDRESS_69,
                            g_fs=mpu_constants.GFS_500,
                            a_fs=mpu_constants.AFS_2G,
                            m_fs=mpu_constants.AK8963_BIT_16,
                            mode=mpu_constants.AK8963_MODE_C8HZ,
                            a_bias=(0, 0, 0), g_bias=(0, 0, 0),
                            m_bias=(0, 0, 0),
                            mag_scale=(1, 1, 1),
                            callback=None
                            ):
        &#34;&#34;&#34;
        This method instantiates an mpu_9250 object.
        It also creates the thread to manage the mpu_9250 data retrieval.

        :param address_ak: AK8963 I2C address (default:AK8963_ADDRESS[0x0C]).

        :param address_mpu:  MPU-9250 I2C address (default:MPU9050_ADDRESS_68[0x68]).

        :param g_fs: Gyroscope full scale select (default:GFS_2000[2000dps]).

        :param a_fs: Accelerometer full scale select (default:AFS_16G[16g]).

        :param m_fs: Magnetometer scale select (default:AK8963_BIT_16[16bit])

        :param mode: Magnetometer mode select (default:AK8963_MODE_C8HZ)

        :param a_bias: Accelerometer Bias

        :param g_bias: Gyroscope Bias

        :param m_bias: Magnetometer Hard Iron Distortion

        :param mag_scale: Magnetometer Soft Iron Distortion

        :param callback: Callback method that will receive mpu data frames

        &#34;&#34;&#34;
        self.mpu_callback = callback

        # make sure that we initialize i2c mode
        self.set_pin_mode_i2c()

        self.mpu_9250_device = MPU9250(self, address_ak, address_mpu,
                                       g_fs, a_fs, m_fs, mode,
                                       mag_scale=mag_scale, g_bias=g_bias,
                                       a_bias=a_bias, m_bias=m_bias)
        self.mpu_callback = callback

    def mpu_9250_read_data(self, mode=mpu_constants.MPU9250_READ_CONTINUOUS_ON,
                           continuous_delay=0.3):
        &#34;&#34;&#34;
        Read and report mpu_9250 data for accelerometer, gyroscope,
        magnetometer, and device temperature.

        :param mode: MPU9250_READ_CONTINUOUS_ON(0) - data is read continuously, or
                     MPU9250_READ_CONTINUOUS_OFF - turn off continuous reads.

        :param continuous_delay: Delay between reads

        :return: For MPU9250_READ_CONTINUOUS_ON, if a callback was specified in
        mpu_9250_initialize(), then data returned is returned via callback.

                 Callback data is a list with format:
                 index[0] = pin type - for mpu9250 the value is 16
                 index[1] = mpu address
                 index[2] = accelerometer x axis
                 index[3] = accelerometer y axis
                 index[4] = accelerometer z axis
                 index[5] = gyroscope x axis
                 index[6] = gyroscope y axis
                 index[7] = gyroscope z axis
                 index[8] = magnetometer x axis
                 index[9] = magnetometer y axis
                 index[10] = magnetometer z axis
                 index[11] = temperature
                 index[12] = timestamp

                 If no callback was specified, then data is stored and can be
                 retrieved using mpu_9250_read_saved_data().
        &#34;&#34;&#34;
        self.mpu_read_delay = continuous_delay
        if mode == mpu_constants.MPU9250_READ_CONTINUOUS_ON:
            self._mpu9250_thread_run()
        elif mode == mpu_constants.MPU9250_READ_CONTINUOUS_OFF:
            self._mpu9250_thread_stop()
        else:
            raise RuntimeError(f&#39;Unknown mode passed to mpu_9250_read_data(). mode == {mode}&#39;)

    def _mpu_read_device(self):
        &#34;&#34;&#34;
        This is the thread code to continuously read the mpu9250
        :return:
        &#34;&#34;&#34;

        self.mpu_9250_run_event.wait()

        while True:
            mpu_data = [PrivateConstants.MPU9250, self.mpu_9250_device.address_mpu]
            if self._mpu_9250_is_running() and not self.shutdown_flag:
                mpu_data = mpu_data + self.mpu_9250_device.get_all_data()
                mpu_data.append(time.time())
                self.mpu_last_value = mpu_data
                # print(mpu_data)
                if self.mpu_callback:
                    self.mpu_callback(mpu_data)
                time.sleep(self.mpu_read_delay)
            else:
                continue

    def mpu_9250_read_saved_data(self):
        &#34;&#34;&#34;
        Retrieve and return the last data set read from the mpu_9250

        :return: last read data in list form or [] if no data is available.
        &#34;&#34;&#34;
        if self.mpu_9250_device.address_mpu:
            return self.mpu_last_value

    def pwm_write(self, pin, value):
        &#34;&#34;&#34;
        Set the selected pwm pin to the specified value.

        :param pin: PWM pin number

        :param value: Pin value (0 - 0x4000)

        &#34;&#34;&#34;
        if PrivateConstants.PWM_MESSAGE + pin &lt; 0xf0:
            command = [PrivateConstants.PWM_MESSAGE + pin, value &amp; 0x7f,
                       (value &gt;&gt; 7) &amp; 0x7f]
            self._send_command(command)
        else:
            self._pwm_write_extended(pin, value)

    def _pwm_write_extended(self, pin, data):
        &#34;&#34;&#34;
        This method will send an extended-data analog write command to the
        selected pin.

        :param pin: 0 - 127

        :param data: 0 - 0xfffff

        :returns: No return value
        &#34;&#34;&#34;
        pwm_data = [pin, data &amp; 0x7f, (data &gt;&gt; 7) &amp; 0x7f,
                    (data &gt;&gt; 14) &amp; 0x7f]
        self._send_sysex(PrivateConstants.EXTENDED_PWM, pwm_data)

    def send_reset(self):
        &#34;&#34;&#34;
        Send a Sysex reset command to the arduino

        &#34;&#34;&#34;
        try:
            self._send_command([PrivateConstants.SYSTEM_RESET])
        except RuntimeError:
            raise

    def set_pin_mode_analog_input(self, pin_number, callback=None,
                                  differential=1):
        &#34;&#34;&#34;
        Set a pin as an analog input.

        :param pin_number: arduino pin number

        :param callback: callback function

        :param differential: This value needs to be met for a callback
                             to be invoked.


        callback returns a data list:

        [pin_type, pin_number, pin_value, raw_time_stamp]

        The pin_type for analog input pins = 2

        &#34;&#34;&#34;
        self._set_pin_mode(pin_number, PrivateConstants.ANALOG,
                           callback=callback,
                           differential=differential)

    def set_pin_mode_dht(self, pin_number, sensor_type=22, differential=.1, callback=None):
        &#34;&#34;&#34;
        Configure a DHT sensor prior to operation.
        Up to 6 DHT sensors are supported

        :param pin_number: digital pin number on arduino.

        :param sensor_type: type of dht sensor
                            Valid values = DHT11, DHT12, DHT22, DHT21, AM2301

        :param differential: This value needs to be met for a callback
                             to be invoked.

        :param callback: callback function

        callback: returns a data list:

        [pin_type, pin_number, DHT type, humidity value, temperature raw_time_stamp]

        The pin_type for DHT input pins = 15

                ERROR CODES: If either humidity or temperature value:
                              == -1 Configuration Error
                              == -2 Checksum Error
                              == -3 Timeout Error
        &#34;&#34;&#34;

        # if the pin is not currently associated with a DHT device
        # initialize it.
        if pin_number not in self.dht_list:
            self.dht_list.append(pin_number)
            self.digital_pins[pin_number].cb = callback
            self.digital_pins[pin_number].current_value = [0, 0]
            self.digital_pins[pin_number].differential = differential
            data = [pin_number, sensor_type]
            self._send_sysex(PrivateConstants.DHT_CONFIG, data)
        else:
            # allow user to change the differential value
            self.digital_pins[pin_number].differential = differential

    def set_pin_mode_digital_input(self, pin_number, callback=None):
        &#34;&#34;&#34;
        Set a pin as a digital input.

        :param pin_number: arduino pin number

        :param callback: callback function


        callback returns a data list:

        [pin_type, pin_number, pin_value, raw_time_stamp]

        The pin_type for digital input pins = 0

        &#34;&#34;&#34;
        self._set_pin_mode(pin_number, PrivateConstants.INPUT, callback)

    def set_pin_mode_digital_input_pullup(self, pin_number, callback=None):
        &#34;&#34;&#34;
        Set a pin as a digital input with pullup enabled.

        :param pin_number: arduino pin number

        :param callback: callback function


        callback returns a data list:

        [pin_type, pin_number, pin_value, raw_time_stamp]

        The pin_type for digital input pins with pullups enabled = 11

        &#34;&#34;&#34;
        self._set_pin_mode(pin_number, PrivateConstants.PULLUP, callback)

    def set_pin_mode_digital_output(self, pin_number):
        &#34;&#34;&#34;
        Set a pin as a digital output pin.

        :param pin_number: arduino pin number
        &#34;&#34;&#34;

        self._set_pin_mode(pin_number, PrivateConstants.OUTPUT)

    # noinspection PyIncorrectDocstring
    def set_pin_mode_i2c(self, read_delay_time=0):
        &#34;&#34;&#34;
        Establish the standard Arduino i2c pins for i2c utilization.

        NOTE: THIS METHOD MUST BE CALLED BEFORE ANY I2C REQUEST IS MADE
        This method initializes Firmata for I2c operations.

        :param read_delay_time (in microseconds): an optional parameter,
                                                  default is 0

        NOTE: Callbacks are set within the individual i2c read methods of this
              API.
              See i2c_read, i2c_read_continuous, or i2c_read_restart_transmission.

        &#34;&#34;&#34;
        if not self.i2c_configured:
            data = [read_delay_time &amp; 0x7f, (read_delay_time &gt;&gt; 7) &amp; 0x7f]
            self._send_sysex(PrivateConstants.I2C_CONFIG, data)
            self.i2c_configured = True

    def set_pin_mode_pwm_output(self, pin_number):
        &#34;&#34;&#34;
        Set a pin as a pwm (analog output) pin.

        :param pin_number:arduino pin number

        &#34;&#34;&#34;
        self._set_pin_mode(pin_number, PrivateConstants.PWM)

    def set_pin_mode_servo(self, pin, min_pulse=544, max_pulse=2400):
        &#34;&#34;&#34;
        Configure a pin as a servo pin. Set pulse min, max in ms.

        :param pin: Servo Pin.

        :param min_pulse: Min pulse width in ms.

        :param max_pulse: Max pulse width in ms.

        &#34;&#34;&#34;
        command = [pin, min_pulse &amp; 0x7f, (min_pulse &gt;&gt; 7) &amp; 0x7f,
                   max_pulse &amp; 0x7f,
                   (max_pulse &gt;&gt; 7) &amp; 0x7f]

        self._send_sysex(PrivateConstants.SERVO_CONFIG, command)

    def set_pin_mode_sonar(self, trigger_pin, echo_pin,
                           callback=None, timeout=80000):
        &#34;&#34;&#34;
        This is a FirmataExpress feature.

        Configure the pins,ping interval and maximum distance for an HC-SR04
        type device.

        Up to a maximum of 6 SONAR devices is supported.
        If the maximum is exceeded a message is sent to the console and the
        request is ignored.

        NOTE: data is measured in centimeters. Callback is called only when the
              the latest value received is different than the previous.

        :param trigger_pin: The pin number of for the trigger (transmitter).

        :param echo_pin: The pin number for the received echo.

        :param callback: optional callback function to report sonar data changes

        :param timeout: a tuning parameter. 80000UL equals 80ms.


        callback returns a data list:

        [pin_type, trigger_pin_number, distance_value (in cm), raw_time_stamp]

        The pin_type for sonar pins = 12


        &#34;&#34;&#34;
        # if there is an entry for the trigger pin in existence,
        # ignore the duplicate request.
        if trigger_pin in self.active_sonar_map:
            return

        timeout_lsb = timeout &amp; 0x7f
        timeout_msb = (timeout &gt;&gt; 7) &amp; 0x7f
        data = [trigger_pin, echo_pin, timeout_lsb,
                timeout_msb]

        self._set_pin_mode(trigger_pin, PrivateConstants.SONAR,
                           PrivateConstants.INPUT)
        self._set_pin_mode(echo_pin, PrivateConstants.SONAR,
                           PrivateConstants.INPUT)
        # update the ping data map for this pin
        if len(self.active_sonar_map) &gt; 6:
            print(&#39;sonar_config: maximum number of devices assigned&#39;
                  &#39; - ignoring request&#39;)
        else:
            # initialize map entry with callback, data value of 0 and time_stamp of 0
            self.active_sonar_map[trigger_pin] = [callback, 0, 0]

        self._send_sysex(PrivateConstants.SONAR_CONFIG, data)

    def _set_pin_mode(self, pin_number, pin_state, callback=None,
                      differential=1):
        &#34;&#34;&#34;
        A private method to set the various pin modes.

        :param pin_number: arduino pin number

        :param pin_state: INPUT/OUTPUT/ANALOG/PWM/PULLUP
                         For SERVO use: set_pin_mode_servo
                         For DHT   use: set_pin_mode_dht

        :param callback: A reference to a call back function to be
                         called when pin data value changes

        :param differential: This value needs to be met for a callback
                             to be invoked

        &#34;&#34;&#34;
        if callback:
            if pin_state == PrivateConstants.INPUT:
                self.digital_pins[pin_number].cb = callback
            elif pin_state == PrivateConstants.PULLUP:
                self.digital_pins[pin_number].cb = callback
                self.digital_pins[pin_number].pull_up = True
            elif pin_state == PrivateConstants.ANALOG:
                self.analog_pins[pin_number].cb = callback
                self.analog_pins[pin_number].differential = differential
            else:
                print(&#39;{} {}&#39;.format(&#39;set_pin_mode: callback ignored for &#39;
                                     &#39;pin state:&#39;, pin_state))

        pin_mode = pin_state

        if pin_mode == PrivateConstants.ANALOG:
            pin_number = pin_number + self.first_analog_pin

        command = [PrivateConstants.SET_PIN_MODE, pin_number, pin_mode]
        self._send_command(command)

        if pin_state == PrivateConstants.INPUT or pin_state == PrivateConstants.PULLUP:
            self.enable_digital_reporting(pin_number)
        else:
            pass

    def set_sampling_interval(self, interval):
        &#34;&#34;&#34;
        This method sends the desired sampling interval to Firmata.

        Note: Standard Firmata  will ignore any interval less than
              10 milliseconds

        :param interval: Integer value for desired sampling interval
                         in milliseconds

        &#34;&#34;&#34;
        data = [interval &amp; 0x7f, (interval &gt;&gt; 7) &amp; 0x7f]
        self._send_sysex(PrivateConstants.SAMPLING_INTERVAL, data)

    def servo_write(self, pin, position):
        &#34;&#34;&#34;
        This is an alias for analog_write to set
        the position of a servo that has been
        previously configured using set_pin_mode_servo.

        :param pin: arduino pin number

        :param position: servo position

        &#34;&#34;&#34;

        self.pwm_write(pin, position)

    # noinspection PyBroadException
    def shutdown(self):
        &#34;&#34;&#34;
        This method attempts an orderly shutdown
        If any exceptions are thrown, they are ignored.

        &#34;&#34;&#34;

        self.shutdown_flag = True

        self._stop_threads()

        try:
            # stop all reporting - both analog and digital
            for pin in range(len(self.analog_pins)):
                self.disable_analog_reporting(pin)

            for pin in range(len(self.digital_pins)):
                self.disable_digital_reporting(pin)
            self.send_reset()
            if self.ip_address:
                try:
                    self.sock.shutdown(socket.SHUT_RDWR)
                    self.sock.close()
                except Exception:
                    pass
            else:
                self.serial_port.reset_input_buffer()
                self.serial_port.close()

        except (RuntimeError, SerialException, OSError):
            # ignore error on shutdown
            pass

    def sonar_read(self, trigger_pin):
        &#34;&#34;&#34;
        This is a FirmataExpress feature

        Retrieve Ping (HC-SR04 type) data. The data is presented as a
        dictionary.

        The &#39;key&#39; is the trigger pin specified in sonar_config()
        and the &#39;data&#39; is the current measured distance (in centimeters)
        for that pin. If there is no data, the value is set to None.

        :param trigger_pin: key into sonar data map

        :returns: A list = [last value, raw time_stamp]

        &#34;&#34;&#34;

        sonar_pin_entry = self.active_sonar_map.get(trigger_pin)
        if sonar_pin_entry:
            return [sonar_pin_entry[1], sonar_pin_entry[2]]
        else:
            return [0, 0]

    &#39;&#39;&#39;
    Firmata message handlers
    &#39;&#39;&#39;

    def _analog_mapping_response(self, data):
        &#34;&#34;&#34;
        This is a private message handler method.
        It is a message handler for the analog mapping response message.

        :param data: response data

        &#34;&#34;&#34;
        self.query_reply_data[PrivateConstants.ANALOG_MAPPING_RESPONSE] = data

    def _analog_message(self, data):
        &#34;&#34;&#34;
        This is a private message handler method.
        It is a message handler for analog messages.

        :param data: message data

        &#34;&#34;&#34;
        pin = data[0]
        value = (data[PrivateConstants.MSB] &lt;&lt; 7) + data[PrivateConstants.LSB]

        # only report when there is a change in value
        differential = abs(value - self.analog_pins[pin].current_value)
        if differential &gt;= self.analog_pins[pin].differential:
            self.analog_pins[pin].current_value = value
            time_stamp = time.time()
            self.analog_pins[pin].event_time = time_stamp

            # append pin number, pin value, and pin type to return value and return as a list
            message = [PrivateConstants.ANALOG, pin, value, time_stamp]

            if self.analog_pins[pin].cb:
                self.analog_pins[pin].cb(message)

    def _capability_response(self, data):
        &#34;&#34;&#34;
        This is a private message handler method.
        It is a message handler for capability report responses.

        :param data: capability report

        &#34;&#34;&#34;
        self.query_reply_data[PrivateConstants.CAPABILITY_RESPONSE] = data

    def _dht_read_response(self, data):
        &#34;&#34;&#34;
        Process the dht response message.

        Values are calculated using:
                humidity = (_bits[0] * 256 + _bits[1]) * 0.1

                temperature = ((_bits[2] &amp; 0x7F) * 256 + _bits[3]) * 0.1

        error codes:
        0 - OK
        1 - DHTLIB_ERROR_TIMEOUT
        2 - Checksum error

        :param: data - array of 9 7bit bytes ending with the error status
        &#34;&#34;&#34;
        # get the time of the report
        time_stamp = time.time()
        # initiate a list for a potential call back
        reply_data = [PrivateConstants.DHT]

        # get the pin and type of the dht
        pin = data[0]
        reply_data.append(pin)
        dht_type = data[1]
        reply_data.append(dht_type)
        humidity = None
        temperature = None

        self.digital_pins[pin].event_time = time_stamp

        if data[7] == 1:  # data[9] is config flag
            if data[10] != 0:
                self.dht_sensor_error = True
                humidity = temperature = -1
                # return
        else:
            # if data read correctly process and return

            if data[6] == 0:
                # dht 22
                if data[1] == 22:
                    humidity = (data[2] * 256 + data[3]) * 0.1
                    temperature = ((data[4] &amp; 0x7F) * 256 + data[5]) * 0.1
                # dht 11
                elif data[1] == 11:
                    humidity = (data[2]) + (data[3]) * 0.1
                    temperature = (data[4]) + (data[5]) * 0.1
                else:
                    raise RuntimeError(f&#39;Unknown DHT Sensor type reported: {data[2]}&#39;)

                humidity = round(humidity, 2)
                temperature = round(temperature, 2)

                # check for negative temperature
                if data[6] &amp; 0x80:
                    temperature = -temperature

            elif data[7] == 1:
                # Checksum Error
                humidity = temperature = -2
                self.dht_sensor_error = True
            elif data[7] == 2:
                # Timeout Error
                humidity = temperature = -3
                self.dht_sensor_error = True
        # since we initialize
        if humidity is None:
            return
        reply_data.append(humidity)
        reply_data.append(temperature)
        reply_data.append(time_stamp)

        # retrieve the last reported values
        last_value = self.digital_pins[pin].current_value

        self.digital_pins[pin].current_value = [humidity, temperature]
        if self.digital_pins[pin].cb:
            # only report changes
            # has the humidity changed?
            if last_value[0] != humidity:

                differential = abs(humidity - last_value[0])
                if differential &gt;= self.digital_pins[pin].differential:
                    self.digital_pins[pin].cb(reply_data)
                return
            if last_value[1] != temperature:
                differential = abs(temperature - last_value[1])
                if differential &gt;= self.digital_pins[pin].differential:
                    self.digital_pins[pin].cb(reply_data)
                return

    def _digital_message(self, data):
        &#34;&#34;&#34;
        This is a private message handler method.
        It is a message handler for Digital Messages.

        :param data: digital message

        &#34;&#34;&#34;
        port = data[0]
        # noinspection PyPep8
        port_data = (data[PrivateConstants.MSB] &lt;&lt; 7) + data[PrivateConstants.LSB]
        pin = port * 8
        for pin in range(pin, min(pin + 8, len(self.digital_pins))):
            # get pin value
            value = port_data &amp; 0x01

            # retrieve previous value
            last_value = self.digital_pins[pin].current_value

            # set the current value in the pin structure
            self.digital_pins[pin].current_value = value
            time_stamp = time.time()
            self.digital_pins[pin].event_time = time_stamp

            # append pin number, pin value, and pin type to return value and return as a list
            if self.digital_pins[pin].pull_up:
                message = [PrivateConstants.PULLUP, pin, value, time_stamp]
            else:
                message = [PrivateConstants.INPUT, pin, value, time_stamp]

            if last_value != value:
                if self.digital_pins[pin].cb:
                    self.digital_pins[pin].cb(message)

            port_data &gt;&gt;= 1

    # noinspection PyDictCreation

    def _i2c_reply(self, data):
        &#34;&#34;&#34;
        This is a private message handler method.
        It handles replies to i2c_read requests. It stores the data
        for each i2c device address in a dictionary called i2c_map.
        The data may be retrieved via a polling call to i2c_get_read_data().
        It a callback was specified in pymata.i2c_read, the raw data is sent
        through the callback

        :param data: raw data returned from i2c device

        &#34;&#34;&#34;
        # initialize the reply data with I2C pin mode
        reply_data = [PrivateConstants.I2C]
        # reassemble the data from the firmata 2 byte format
        address = (data[0] &amp; 0x7f) + (data[1] &lt;&lt; 7)

        # if we have an entry in the i2c_map, proceed
        if address in self.i2c_map:
            with self.the_i2c_map_lock:
                # get 2 bytes, combine them and append to reply data list
                for i in range(0, len(data), 2):
                    combined_data = (data[i] &amp; 0x7f) + (data[i + 1] &lt;&lt; 7)
                    reply_data.append(combined_data)

                current_time = time.time()
                reply_data.append(current_time)

                # place the data in the i2c map without storing the address byte or
                #  register byte (returned data only)
                map_entry = self.i2c_map.get(address)
                map_entry[&#39;value&#39;] = reply_data[3:]
                map_entry[&#39;time_stamp&#39;] = current_time
                self.i2c_map[address] = map_entry
                cb = map_entry.get(&#39;callback&#39;)
                if cb:
                    # send everything, including address and register bytes back
                    # to caller
                    # reply data will contain:
                    # [pin_type = 6, i2c_device address,
                    #                       raw data returned from i2c device, time-stamp]
                    cb(reply_data)

    def _pin_state_response(self, data):
        &#34;&#34;&#34;
        This is a private message handler method.
        It handles pin state query response messages.

        :param data: Pin state message

        &#34;&#34;&#34;
        self.query_reply_data[PrivateConstants.PIN_STATE_RESPONSE] = data

    def _report_firmware(self, sysex_data):
        &#34;&#34;&#34;
        This is a private message handler method.

        This method handles the sysex &#39;report firmware&#39; command sent by
        Firmata (0x79).

        It assembles the firmware version by concatenating the major and
        minor version number components and the firmware identifier into
        a string.

        e.g. &#34;2.3 StandardFirmata.ino&#34;

        :param sysex_data: Sysex data sent from Firmata

        &#34;&#34;&#34;
        # first byte after command is major number
        major = sysex_data[0]
        version_string = str(major)

        # next byte is minor number
        # minor = sysex_data[2]
        minor = sysex_data[1]

        # append a dot to major number
        version_string += &#39;.&#39;

        # append minor number
        version_string += str(minor)
        # add a space after the major and minor numbers
        version_string += &#39; &#39;

        # slice the identifier - from the first byte after the minor
        #  number up until, but not including the END_SYSEX byte

        # name = sysex_data[3:-1]
        name = sysex_data[2:]

        firmware_name_iterator = iter(name)

        # convert each element from two 7-bit bytes into characters, then add each
        # character to the version string
        for e in firmware_name_iterator:
            version_string += chr(e + (next(firmware_name_iterator) &lt;&lt; 7))

        # store the value
        self.query_reply_data[PrivateConstants.REPORT_FIRMWARE] = version_string

    def _report_version(self, data):
        &#34;&#34;&#34;
        This is a private message handler method.

        This method reads the following 2 bytes after the report version
        command (0xF9 - non sysex).

        The first byte is the major number and the second byte is the
        minor number.

        &#34;&#34;&#34;
        version_string = str(data[0]) + &#39;.&#39; + str(data[1])
        self.query_reply_data[PrivateConstants.REPORT_VERSION] = version_string

    def _send_command(self, command):
        &#34;&#34;&#34;
        This is a private utility method.
        The method sends a non-sysex command to Firmata.

        :param command:  command data

        :returns: number of bytes sent
        &#34;&#34;&#34;
        # send_message = &#34;&#34;
        send_message = bytes(command)
        if not self.ip_address:
            try:
                result = self.serial_port.write(send_message)
            except SerialException:
                if self.shutdown_on_exception:
                    self.shutdown()
                raise RuntimeError(&#39;write fail in _send_command&#39;)
            return result
        else:
            self.sock.sendall(send_message)

    def _sonar_data(self, data):
        &#34;&#34;&#34;
        This method handles the incoming sonar data message and stores
        the data in the response table.

        :param data: Message data from Firmata

        &#34;&#34;&#34;

        pin_number = data[0]
        val = int((data[PrivateConstants.MSB] &lt;&lt; 7) +
                  data[PrivateConstants.LSB])
        # initialize reply_data with SONAR pin type
        reply_data = [PrivateConstants.SONAR]

        with self.the_sonar_map_lock:
            sonar_pin_entry = self.active_sonar_map[pin_number]
            if sonar_pin_entry[0] is not None:
                # check if value changed since last reading
                if sonar_pin_entry[1] != val:
                    sonar_pin_entry[1] = val
                    time_stamp = time.time()
                    sonar_pin_entry[2] = time_stamp
                    self.active_sonar_map[pin_number] = sonar_pin_entry
                    # Do a callback if one is specified in the table
                    if sonar_pin_entry[0]:
                        reply_data.append(pin_number)
                        reply_data.append(val)
                        reply_data.append(time_stamp)
                        if sonar_pin_entry[1]:
                            sonar_pin_entry[0](reply_data)

                # update the data in the table with latest value
                else:
                    sonar_pin_entry[1] = val
                    self.active_sonar_map[pin_number] = sonar_pin_entry
            time.sleep(self.sleep_tune)

    def _send_sysex(self, sysex_command, sysex_data=None):
        &#34;&#34;&#34;
        This is a private utility method.
        This method sends a sysex command to Firmata.

        :param sysex_command: sysex command

        :param sysex_data: data for command

        &#34;&#34;&#34;
        if not sysex_data:
            sysex_data = []

        the_command = [PrivateConstants.START_SYSEX, sysex_command]
        if sysex_data:
            for d in sysex_data:
                the_command.append(d)
        the_command.append(PrivateConstants.END_SYSEX)
        with self.the_send_sysex_lock:
            self._send_command(the_command)

    # noinspection PyMethodMayBeStatic
    def _string_data(self, data):
        &#34;&#34;&#34;
        This is a private message handler method.
        It is the message handler for String data messages that will be
        printed to the console.

        :param data:  message

        &#34;&#34;&#34;
        reply = &#39;&#39;
        for x in data:
            reply_data = x
            if reply_data:
                reply += chr(reply_data)
        print(reply)

    def _run_threads(self):
        self.run_event.set()

    def _is_running(self):
        return self.run_event.is_set()

    def _mpu9250_thread_run(self):
        self.mpu_9250_run_event.set()

    def _mpu9250_thread_stop(self):
        self.mpu_9250_run_event.clear()

    def _mpu_9250_is_running(self):
        return self.mpu_9250_run_event.is_set()

    def _stop_threads(self):
        self.run_event.clear()
        self.mpu_9250_run_event.clear()

    def _reporter(self):
        &#34;&#34;&#34;
        This is the reporter thread. It continuously pulls data from
        the deque. When a full message is detected, that message is
        processed.
        &#34;&#34;&#34;
        self.run_event.wait()

        # sysex commands are assembled into this list for processing
        # next_command_byte = None
        while self._is_running() and not self.shutdown_flag:
            if len(self.the_deque):

                # get next byte from the deque and process it
                data = self.the_deque.popleft()

                # this list will be populated with the received data for the command
                response_data = []

                # process sysex commands
                if data == PrivateConstants.START_SYSEX:
                    # next char is the actual sysex command
                    # wait until we can get data from the deque
                    while len(self.the_deque) == 0:
                        pass
                    sysex_command = self.the_deque.popleft()
                    # retrieve the associated command_dispatch entry for this command
                    dispatch_entry = self.report_dispatch.get(sysex_command)

                    # get a &#34;pointer&#34; to the method that will process this command
                    method = dispatch_entry[0]

                    # now get the rest of the data excluding the END_SYSEX byte
                    end_of_sysex = False
                    while not end_of_sysex:
                        # wait for more data to arrive
                        while len(self.the_deque) == 0:
                            pass
                        data = self.the_deque.popleft()
                        if data != PrivateConstants.END_SYSEX:
                            response_data.append(data)
                        else:
                            end_of_sysex = True

                            # invoke the method to process the command
                            method(response_data)
                            # go to the beginning of the loop to process the next command
                    continue

                # is this a command byte in the range of 0x80-0xff - these are the non-sysex messages

                elif 0x80 &lt;= data &lt;= 0xff:
                    # look up the method for the command in the command dispatch table
                    # for the digital reporting the command value is modified with port number
                    # the handler needs the port to properly process, so decode that from the command and
                    # place in response_data
                    if 0x90 &lt;= data &lt;= 0x9f:
                        port = data &amp; 0xf
                        response_data.append(port)
                        data = 0x90
                    # the pin number for analog data is embedded in the command so, decode it
                    elif 0xe0 &lt;= data &lt;= 0xef:
                        pin = data &amp; 0xf
                        response_data.append(pin)
                        data = 0xe0
                    else:
                        pass

                    dispatch_entry = self.report_dispatch.get(data)

                    # this calls the method retrieved from the dispatch table
                    method = dispatch_entry[0]

                    # get the number of parameters that this command provides
                    num_args = dispatch_entry[1]

                    # look at the number of args that the selected method requires
                    # now get that number of bytes to pass to the called method
                    for i in range(num_args):
                        while len(self.the_deque) == 0:
                            pass
                        data = self.the_deque.popleft()
                        response_data.append(data)
                        # go execute the command with the argument list
                    method(response_data)

                    # go to the beginning of the loop to process the next command
                    continue
            else:
                time.sleep(self.sleep_tune)

    def _serial_receiver(self):
        &#34;&#34;&#34;
        Thread to continuously check for incoming data.
        When a byte comes in, place it onto the deque.
        &#34;&#34;&#34;
        self.run_event.wait()

        while self._is_running() and not self.shutdown_flag:
            # we can get an OSError: [Errno9] Bad file descriptor when shutting down
            # just ignore it
            try:
                if self.serial_port.inWaiting():
                    c = self.serial_port.read()
                    self.the_deque.append(ord(c))
                else:
                    time.sleep(self.sleep_tune)
                    # continue
            except OSError:
                pass

    # noinspection PyBroadException
    def _tcp_receiver(self):
        &#34;&#34;&#34;
        Thread to continuously check for incoming data.
        When a byte comes in, place it onto the deque.
        &#34;&#34;&#34;
        self.run_event.wait()
        while self._is_running() and not self.shutdown_flag:
            try:
                payload = self.sock.recv(1)
                self.the_deque.append(ord(payload))
            except Exception:
                pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>threading.Thread</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pymata_rh.pymata_rh.PymataRh.analog_read"><code class="name flex">
<span>def <span class="ident">analog_read</span></span>(<span>self, pin)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve the last data update for the specified analog pin.</p>
<p>:param pin: Analog pin number (ex. A2 is specified as 2)</p>
<p>:returns: A list = [last value change,
time_stamp]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def analog_read(self, pin):
    &#34;&#34;&#34;
    Retrieve the last data update for the specified analog pin.

    :param pin: Analog pin number (ex. A2 is specified as 2)

    :returns: A list = [last value change,  time_stamp]
    &#34;&#34;&#34;
    return self.analog_pins[pin].current_value, self.analog_pins[pin].event_time</code></pre>
</details>
</dd>
<dt id="pymata_rh.pymata_rh.PymataRh.dht_read"><code class="name flex">
<span>def <span class="ident">dht_read</span></span>(<span>self, pin)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve the last data update for the specified dht pin.</p>
<p>:param pin: digital pin number</p>
<p>:return: A list = [humidity, temperature
time_stamp]</p>
<pre><code>     ERROR CODES: If either humidity or temperature value:
                  == -1 Configuration Error
                  == -2 Checksum Error
                  == -3 Timeout Error
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dht_read(self, pin):
    &#34;&#34;&#34;
    Retrieve the last data update for the specified dht pin.

    :param pin: digital pin number

    :return: A list = [humidity, temperature  time_stamp]

             ERROR CODES: If either humidity or temperature value:
                          == -1 Configuration Error
                          == -2 Checksum Error
                          == -3 Timeout Error

    &#34;&#34;&#34;
    return self.digital_pins[pin].current_value[0], \
           self.digital_pins[pin].current_value[1], \
           self.digital_pins[pin].event_time</code></pre>
</details>
</dd>
<dt id="pymata_rh.pymata_rh.PymataRh.digital_read"><code class="name flex">
<span>def <span class="ident">digital_read</span></span>(<span>self, pin)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve the last data update for the specified digital pin.</p>
<p>:param pin: Digital pin number</p>
<p>:returns: A list = [last value change,
time_stamp]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def digital_read(self, pin):
    &#34;&#34;&#34;
    Retrieve the last data update for the specified digital pin.

    :param pin: Digital pin number

    :returns: A list = [last value change,  time_stamp]

    &#34;&#34;&#34;
    return [self.digital_pins[pin].current_value, self.digital_pins[pin].event_time]</code></pre>
</details>
</dd>
<dt id="pymata_rh.pymata_rh.PymataRh.digital_write"><code class="name flex">
<span>def <span class="ident">digital_write</span></span>(<span>self, pin, value)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the specified pin to the specified value.</p>
<p>:param pin: arduino pin number</p>
<p>:param value: pin value (1 or 0)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def digital_write(self, pin, value):
    &#34;&#34;&#34;
    Set the specified pin to the specified value.

    :param pin: arduino pin number

    :param value: pin value (1 or 0)

    &#34;&#34;&#34;
    # The command value is not a fixed value, but needs to be calculated
    # using the pin&#39;s port number
    port = pin // 8

    calculated_command = PrivateConstants.DIGITAL_MESSAGE + port
    mask = 1 &lt;&lt; (pin % 8)
    # Calculate the value for the pin&#39;s position in the port mask
    if value == 1:
        PrivateConstants.DIGITAL_OUTPUT_PORT_PINS[port] |= mask
    else:
        PrivateConstants.DIGITAL_OUTPUT_PORT_PINS[port] &amp;= ~mask

    # Assemble the command
    command = (calculated_command,
               PrivateConstants.DIGITAL_OUTPUT_PORT_PINS[port] &amp; 0x7f,
               (PrivateConstants.DIGITAL_OUTPUT_PORT_PINS[port] &gt;&gt; 7)
               &amp; 0x7f)

    self._send_command(command)</code></pre>
</details>
</dd>
<dt id="pymata_rh.pymata_rh.PymataRh.disable_analog_reporting"><code class="name flex">
<span>def <span class="ident">disable_analog_reporting</span></span>(<span>self, pin)</span>
</code></dt>
<dd>
<div class="desc"><p>Disables analog reporting for a single analog pin.</p>
<p>:param pin: Analog pin number. For example for A0, the number is 0.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disable_analog_reporting(self, pin):
    &#34;&#34;&#34;
    Disables analog reporting for a single analog pin.

    :param pin: Analog pin number. For example for A0, the number is 0.

    &#34;&#34;&#34;
    pin = pin + self.first_analog_pin
    self.set_pin_mode_digital_input(pin)</code></pre>
</details>
</dd>
<dt id="pymata_rh.pymata_rh.PymataRh.disable_digital_reporting"><code class="name flex">
<span>def <span class="ident">disable_digital_reporting</span></span>(<span>self, pin)</span>
</code></dt>
<dd>
<div class="desc"><p>Disables digital reporting. By turning reporting off for this pin,
Reporting is disabled for all 8 bits in the "port"</p>
<p>:param pin: Pin and all pins for this port</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disable_digital_reporting(self, pin):
    &#34;&#34;&#34;
    Disables digital reporting. By turning reporting off for this pin,
    Reporting is disabled for all 8 bits in the &#34;port&#34;

    :param pin: Pin and all pins for this port

    &#34;&#34;&#34;
    port = pin // 8
    command = [PrivateConstants.REPORT_DIGITAL + port,
               PrivateConstants.REPORTING_DISABLE]
    self._send_command(command)</code></pre>
</details>
</dd>
<dt id="pymata_rh.pymata_rh.PymataRh.enable_analog_reporting"><code class="name flex">
<span>def <span class="ident">enable_analog_reporting</span></span>(<span>self, pin, callback=None, differential=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Enables analog reporting. This is an alias for set_pin_mode_analog_input.
Disabling analog reporting sets the pin to a digital input pin,
so we need to provide the callback and differential if we wish
to specify it.</p>
<p>:param pin: Analog pin number. For example for A0, the number is 0.</p>
<p>:param callback: callback function</p>
<p>:param differential: This value needs to be met for a callback
to be invoked.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def enable_analog_reporting(self, pin, callback=None, differential=1):
    &#34;&#34;&#34;
    Enables analog reporting. This is an alias for set_pin_mode_analog_input.
    Disabling analog reporting sets the pin to a digital input pin,
    so we need to provide the callback and differential if we wish
    to specify it.

    :param pin: Analog pin number. For example for A0, the number is 0.

    :param callback: callback function

    :param differential: This value needs to be met for a callback
                         to be invoked.
    &#34;&#34;&#34;
    self.set_pin_mode_analog_input(pin, callback, differential)</code></pre>
</details>
</dd>
<dt id="pymata_rh.pymata_rh.PymataRh.enable_digital_reporting"><code class="name flex">
<span>def <span class="ident">enable_digital_reporting</span></span>(<span>self, pin)</span>
</code></dt>
<dd>
<div class="desc"><p>Enables digital reporting. By turning reporting on for all 8 bits
in the "port" - this is part of Firmata's protocol specification.</p>
<p>:param pin: Pin and all pins for this port</p>
<p>:returns: No return value</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def enable_digital_reporting(self, pin):
    &#34;&#34;&#34;
    Enables digital reporting. By turning reporting on for all 8 bits
    in the &#34;port&#34; - this is part of Firmata&#39;s protocol specification.

    :param pin: Pin and all pins for this port

    :returns: No return value
        &#34;&#34;&#34;
    port = pin // 8
    command = [PrivateConstants.REPORT_DIGITAL + port,
               PrivateConstants.REPORTING_ENABLE]
    self._send_command(command)</code></pre>
</details>
</dd>
<dt id="pymata_rh.pymata_rh.PymataRh.get_analog_map"><code class="name flex">
<span>def <span class="ident">get_analog_map</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This method requests a Firmata analog map query and returns the
results.</p>
<p>:returns: An analog map response or None if a timeout occurs</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_analog_map(self):
    &#34;&#34;&#34;
    This method requests a Firmata analog map query and returns the
    results.

    :returns: An analog map response or None if a timeout occurs
    &#34;&#34;&#34;
    # get the current time to make sure a report is retrieved
    current_time = time.time()

    # if we do not have existing report results, send a Firmata
    # message to request one

    self._send_sysex(PrivateConstants.ANALOG_MAPPING_QUERY)
    # wait for the report results to return for 4 seconds
    # if the timer expires, return None
    while self.query_reply_data.get(
            PrivateConstants.ANALOG_MAPPING_RESPONSE) is None:
        elapsed_time = time.time()
        if elapsed_time - current_time &gt; 4:
            return None
        # time.sleep(self.sleep_tune)
        time.sleep(.01)
    return self.query_reply_data.get(PrivateConstants.ANALOG_MAPPING_RESPONSE)</code></pre>
</details>
</dd>
<dt id="pymata_rh.pymata_rh.PymataRh.get_capability_report"><code class="name flex">
<span>def <span class="ident">get_capability_report</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This method requests and returns a Firmata capability query report</p>
<p>:returns: A capability report in the form of a list</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_capability_report(self):
    &#34;&#34;&#34;
    This method requests and returns a Firmata capability query report

    :returns: A capability report in the form of a list
    &#34;&#34;&#34;

    self._send_sysex(PrivateConstants.CAPABILITY_QUERY)
    while self.query_reply_data.get(
            PrivateConstants.CAPABILITY_RESPONSE) is None:
        time.sleep(self.sleep_tune)
    return self.query_reply_data.get(PrivateConstants.CAPABILITY_RESPONSE)</code></pre>
</details>
</dd>
<dt id="pymata_rh.pymata_rh.PymataRh.get_firmware_version"><code class="name flex">
<span>def <span class="ident">get_firmware_version</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This method retrieves the Firmata firmware version</p>
<p>:returns: Firmata firmware version</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_firmware_version(self):
    &#34;&#34;&#34;
    This method retrieves the Firmata firmware version

    :returns: Firmata firmware version
    &#34;&#34;&#34;
    self._send_sysex(PrivateConstants.REPORT_FIRMWARE)

    current_time = time.time()
    while self.query_reply_data.get(PrivateConstants.REPORT_FIRMWARE) == &#39;&#39;:
        elapsed_time = time.time()
        if elapsed_time - current_time &gt; 4:
            return None
        time.sleep(self.sleep_tune)
    return self.query_reply_data.get(PrivateConstants.REPORT_FIRMWARE)</code></pre>
</details>
</dd>
<dt id="pymata_rh.pymata_rh.PymataRh.get_pin_state"><code class="name flex">
<span>def <span class="ident">get_pin_state</span></span>(<span>self, pin)</span>
</code></dt>
<dd>
<div class="desc"><p>This method retrieves a pin state report for the specified pin.
Pin modes reported:</p>
<p>INPUT
= 0x00
# digital input mode</p>
<p>OUTPUT
= 0x01
# digital output mode</p>
<p>ANALOG
= 0x02
# analog input mode</p>
<p>PWM
= 0x03
# digital pin in PWM output mode</p>
<p>SERVO
= 0x04
# digital pin in Servo output mode</p>
<p>I2C
= 0x06
# pin included in I2C setup</p>
<p>STEPPER = 0x08
# digital pin in stepper mode</p>
<p>PULLUP
= 0x0b
# digital pin in input pullup mode</p>
<p>SONAR
= 0x0c
# digital pin in SONAR mode</p>
<p>TONE
= 0x0d
# digital pin in tone mode</p>
<p>:param pin: Pin of interest</p>
<p>:returns: pin state report</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_pin_state(self, pin):
    &#34;&#34;&#34;
    This method retrieves a pin state report for the specified pin.
    Pin modes reported:

    INPUT   = 0x00  # digital input mode

    OUTPUT  = 0x01  # digital output mode

    ANALOG  = 0x02  # analog input mode

    PWM     = 0x03  # digital pin in PWM output mode

    SERVO   = 0x04  # digital pin in Servo output mode

    I2C     = 0x06  # pin included in I2C setup

    STEPPER = 0x08  # digital pin in stepper mode

    PULLUP  = 0x0b  # digital pin in input pullup mode

    SONAR   = 0x0c  # digital pin in SONAR mode

    TONE    = 0x0d  # digital pin in tone mode

    :param pin: Pin of interest

    :returns: pin state report

    &#34;&#34;&#34;
    # place pin in a list to keep _send_sysex happy
    self._send_sysex(PrivateConstants.PIN_STATE_QUERY, [pin])
    while self.query_reply_data.get(
            PrivateConstants.PIN_STATE_RESPONSE) is None:
        time.sleep(self.sleep_tune)
    pin_state_report = self.query_reply_data.get(
        PrivateConstants.PIN_STATE_RESPONSE)
    self.query_reply_data[PrivateConstants.PIN_STATE_RESPONSE] = None
    return pin_state_report</code></pre>
</details>
</dd>
<dt id="pymata_rh.pymata_rh.PymataRh.get_protocol_version"><code class="name flex">
<span>def <span class="ident">get_protocol_version</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This method returns the major and minor values for the protocol
version, i.e. 2.5</p>
<p>:returns: Firmata protocol version</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_protocol_version(self):
    &#34;&#34;&#34;
    This method returns the major and minor values for the protocol
    version, i.e. 2.5

    :returns: Firmata protocol version
    &#34;&#34;&#34;
    self._send_command([PrivateConstants.REPORT_VERSION])
    while self.query_reply_data.get(
            PrivateConstants.REPORT_VERSION) == &#39;&#39;:
        time.sleep(self.sleep_tune)
    # v_major =
    return self.query_reply_data.get(PrivateConstants.REPORT_VERSION)</code></pre>
</details>
</dd>
<dt id="pymata_rh.pymata_rh.PymataRh.get_pymata_version"><code class="name flex">
<span>def <span class="ident">get_pymata_version</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This method retrieves the PyMata Express version number</p>
<p>:returns: PyMata Express version number.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_pymata_version(self):
    &#34;&#34;&#34;
    This method retrieves the PyMata Express version number

    :returns: PyMata Express version number.
    &#34;&#34;&#34;
    return PrivateConstants.PYMATA_EXPRESS_THREADED_VERSION</code></pre>
</details>
</dd>
<dt id="pymata_rh.pymata_rh.PymataRh.i2c_read"><code class="name flex">
<span>def <span class="ident">i2c_read</span></span>(<span>self, address, register, number_of_bytes, callback=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Read the specified number of bytes from the specified register for
the i2c device.</p>
<p>:param address: i2c device address</p>
<p>:param register: i2c register (or None if no register selection is needed)</p>
<p>:param number_of_bytes: number of bytes to be read</p>
<p>:param callback: Optional callback function to report i2c data as a
result of read command</p>
<p>callback returns a data list:</p>
<p>[pin_type, i2c_device_address, i2c_read_register, data_bytes returned, time_stamp]</p>
<p>The pin_type for i2c = 6</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def i2c_read(self, address, register, number_of_bytes,
             callback=None):
    &#34;&#34;&#34;
    Read the specified number of bytes from the specified register for
    the i2c device.


    :param address: i2c device address

    :param register: i2c register (or None if no register selection is needed)

    :param number_of_bytes: number of bytes to be read

    :param callback: Optional callback function to report i2c data as a
               result of read command


    callback returns a data list:

    [pin_type, i2c_device_address, i2c_read_register, data_bytes returned, time_stamp]

    The pin_type for i2c = 6

    &#34;&#34;&#34;
    with self.the_i2c_send_lock:
        self._i2c_read_request(address, register, number_of_bytes,
                               PrivateConstants.I2C_READ, callback)</code></pre>
</details>
</dd>
<dt id="pymata_rh.pymata_rh.PymataRh.i2c_read_continuous"><code class="name flex">
<span>def <span class="ident">i2c_read_continuous</span></span>(<span>self, address, register, number_of_bytes, callback=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Some i2c devices support a continuous streaming data output.
This command enables that mode for the device that supports
continuous reads.</p>
<p>:param address: i2c device address</p>
<p>:param register: i2c register (or None if no register selection is needed)</p>
<p>:param number_of_bytes: number of bytes to be read</p>
<p>:param callback: Optional callback function to report i2c data as a
result of read command</p>
<p>callback returns a data list:</p>
<p>[pin_type, i2c_device_address, i2c_read_register, data_bytes returned, time_stamp]</p>
<p>The pin_type for i2c = 6</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def i2c_read_continuous(self, address, register, number_of_bytes,
                        callback=None):
    &#34;&#34;&#34;
    Some i2c devices support a continuous streaming data output.
    This command enables that mode for the device that supports
    continuous reads.


    :param address: i2c device address

    :param register: i2c register (or None if no register selection is needed)

    :param number_of_bytes: number of bytes to be read

    :param callback: Optional callback function to report i2c data as a
               result of read command


    callback returns a data list:

    [pin_type, i2c_device_address, i2c_read_register, data_bytes returned, time_stamp]

    The pin_type for i2c = 6


    &#34;&#34;&#34;
    with self.the_i2c_send_lock:
        self._i2c_read_request(address, register, number_of_bytes,
                               PrivateConstants.I2C_READ_CONTINUOUSLY,
                               callback)</code></pre>
</details>
</dd>
<dt id="pymata_rh.pymata_rh.PymataRh.i2c_read_restart_transmission"><code class="name flex">
<span>def <span class="ident">i2c_read_restart_transmission</span></span>(<span>self, address, register, number_of_bytes, callback=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Read the specified number of bytes from the specified register for
the i2c device. This restarts the transmission after the read. It is
required for some i2c devices such as the MMA8452Q accelerometer.</p>
<p>:param address: i2c device address</p>
<p>:param register: i2c register (or None if no register
selection is needed)</p>
<p>:param number_of_bytes: number of bytes to be read</p>
<p>:param callback: Optional callback function to report i2c data as a
result of read command</p>
<p>callback returns a data list:</p>
<p>[pin_type, i2c_device_address, i2c_read_register, data_bytes returned, time_stamp]</p>
<p>The pin_type for i2c pins = 6</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def i2c_read_restart_transmission(self, address, register,
                                  number_of_bytes,
                                  callback=None):
    &#34;&#34;&#34;
    Read the specified number of bytes from the specified register for
    the i2c device. This restarts the transmission after the read. It is
    required for some i2c devices such as the MMA8452Q accelerometer.


    :param address: i2c device address

    :param register: i2c register (or None if no register
                                                selection is needed)

    :param number_of_bytes: number of bytes to be read

    :param callback: Optional callback function to report i2c data as a
               result of read command


    callback returns a data list:

    [pin_type, i2c_device_address, i2c_read_register, data_bytes returned, time_stamp]

    The pin_type for i2c pins = 6

    &#34;&#34;&#34;
    with self.the_i2c_send_lock:
        self._i2c_read_request(address, register, number_of_bytes,
                               PrivateConstants.I2C_READ
                               | PrivateConstants.I2C_END_TX_MASK,
                               callback)</code></pre>
</details>
</dd>
<dt id="pymata_rh.pymata_rh.PymataRh.i2c_read_saved_data"><code class="name flex">
<span>def <span class="ident">i2c_read_saved_data</span></span>(<span>self, address)</span>
</code></dt>
<dd>
<div class="desc"><p>This method retrieves cached i2c data to support a polling mode.</p>
<p>:param address: I2C device address</p>
<p>:returns data: [raw data returned from i2c device, time-stamp]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def i2c_read_saved_data(self, address):
    &#34;&#34;&#34;
    This method retrieves cached i2c data to support a polling mode.

    :param address: I2C device address

    :returns data: [raw data returned from i2c device, time-stamp]

    &#34;&#34;&#34;
    if address in self.i2c_map:
        with self.the_i2c_map_lock:
            map_entry = self.i2c_map.get(address)
            return map_entry.get(&#39;value&#39;)
    else:
        return None</code></pre>
</details>
</dd>
<dt id="pymata_rh.pymata_rh.PymataRh.i2c_write"><code class="name flex">
<span>def <span class="ident">i2c_write</span></span>(<span>self, address, args)</span>
</code></dt>
<dd>
<div class="desc"><p>Write data to an i2c device.</p>
<p>:param address: i2c device address</p>
<p>:param args: A variable number of bytes to be sent to the device
passed in as a list</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def i2c_write(self, address, args):
    &#34;&#34;&#34;
    Write data to an i2c device.

    :param address: i2c device address

    :param args: A variable number of bytes to be sent to the device
                 passed in as a list

    &#34;&#34;&#34;
    with self.the_i2c_send_lock:
        data = [address, PrivateConstants.I2C_WRITE]
        for item in args:
            item_lsb = item &amp; 0x7f
            data.append(item_lsb)
            item_msb = (item &gt;&gt; 7) &amp; 0x7f
            data.append(item_msb)
        self._send_sysex(PrivateConstants.I2C_REQUEST, data)</code></pre>
</details>
</dd>
<dt id="pymata_rh.pymata_rh.PymataRh.ina_initialize"><code class="name flex">
<span>def <span class="ident">ina_initialize</span></span>(<span>self, address=64, shunt_ohms=0.2, max_expected_amps=0.2, callback=None)</span>
</code></dt>
<dd>
<div class="desc"><p>This method instantiates an INA219 object.</p>
<p>:param address: The i2c address of the device</p>
<p>:param shunt_ohms: The shunt resistance in ohms</p>
<p>:param max_expected_amps: The maximum expected current in amps</p>
<p>:param callback: Callback method that will INA219 callbacks</p>
<p>Note: There is a single callback shared by all INA methods.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ina_initialize(self, address=0x40, shunt_ohms=0.2,
                   max_expected_amps=0.2, callback=None):
    &#34;&#34;&#34;
    This method instantiates an INA219 object.

    :param address: The i2c address of the device

    :param shunt_ohms: The shunt resistance in ohms

    :param max_expected_amps: The maximum expected current in amps

    :param callback: Callback method that will INA219 callbacks

    Note: There is a single callback shared by all INA methods.

    &#34;&#34;&#34;
    # make sure that we initialize i2c mode
    self.set_pin_mode_i2c()

    # instantiate ina_219 and save callback
    self.ina219 = INA219(self, shunt_ohms, max_expected_amps, address)
    self.ina219.configure(self.ina219.RANGE_16V, self.ina219.GAIN_AUTO)
    self.ina219_callback = callback</code></pre>
</details>
</dd>
<dt id="pymata_rh.pymata_rh.PymataRh.ina_read_bus_current"><code class="name flex">
<span>def <span class="ident">ina_read_bus_current</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This method well execute a read of the bus current.
If a callback was specified in ina_initialize, then
a callback frame is specified as follows:</p>
<p>[pin_type=0x11, device_i2c_address, read_type=1 (bus current), current, units='mA', timestamp]</p>
<p>The data is also saved to be retrieved by ina_read_bus_current_last()</p>
<p>:return: callback is called and storage updated with latest value</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ina_read_bus_current(self):
    &#34;&#34;&#34;
    This method well execute a read of the bus current.
    If a callback was specified in ina_initialize, then
    a callback frame is specified as follows:

    [pin_type=0x11, device_i2c_address, read_type=1 (bus current), current, units=&#39;mA&#39;, timestamp]

    The data is also saved to be retrieved by ina_read_bus_current_last()

    :return: callback is called and storage updated with latest value
    &#34;&#34;&#34;
    # noinspection PyProtectedMember
    self.ina219.current()</code></pre>
</details>
</dd>
<dt id="pymata_rh.pymata_rh.PymataRh.ina_read_bus_current_last"><code class="name flex">
<span>def <span class="ident">ina_read_bus_current_last</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve last supply voltage value read from the ina_219.</p>
<p>:return: list:</p>
<p>[pin_type=0x11, device_i2c_address, read_type=1 (bus voltage), voltage, units='mA', timestamp]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ina_read_bus_current_last(self):
    &#34;&#34;&#34;
    Retrieve last supply voltage value read from the ina_219.


    :return: list:

    [pin_type=0x11, device_i2c_address, read_type=1 (bus voltage), voltage, units=&#39;mA&#39;, timestamp]
    &#34;&#34;&#34;
    return self.ina_last_value_bus_current</code></pre>
</details>
</dd>
<dt id="pymata_rh.pymata_rh.PymataRh.ina_read_bus_voltage"><code class="name flex">
<span>def <span class="ident">ina_read_bus_voltage</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This method well execute a read of the bus voltage.
If a callback was specified in ina_initialize, then
a callback frame is specified as follows:</p>
<p>[pin_type=0x11, device_i2c_address, read_type=0 (bus voltage), voltage, units='V', timestamp]</p>
<p>The data is also saved to be retrieved by ina_read_supply_voltage_last()</p>
<p>:return: callback is called and storage updated with latest value</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ina_read_bus_voltage(self):
    &#34;&#34;&#34;
    This method well execute a read of the bus voltage.
    If a callback was specified in ina_initialize, then
    a callback frame is specified as follows:

    [pin_type=0x11, device_i2c_address, read_type=0 (bus voltage), voltage, units=&#39;V&#39;, timestamp]

    The data is also saved to be retrieved by ina_read_supply_voltage_last()

    :return: callback is called and storage updated with latest value
    &#34;&#34;&#34;
    # noinspection PyProtectedMember
    self.ina219.voltage()</code></pre>
</details>
</dd>
<dt id="pymata_rh.pymata_rh.PymataRh.ina_read_bus_voltage_last"><code class="name flex">
<span>def <span class="ident">ina_read_bus_voltage_last</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve last bus voltage value read from the ina_219.</p>
<p>:return: list: [pin_type=0x11, device_i2c_address, read_type=0 (bus voltage), units='V', timestamp]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ina_read_bus_voltage_last(self):
    &#34;&#34;&#34;
    Retrieve last bus voltage value read from the ina_219.

    :return: list: [pin_type=0x11, device_i2c_address, read_type=0 (bus voltage), units=&#39;V&#39;, timestamp]
    &#34;&#34;&#34;
    return self.ina_last_value_bus_voltage</code></pre>
</details>
</dd>
<dt id="pymata_rh.pymata_rh.PymataRh.ina_read_power"><code class="name flex">
<span>def <span class="ident">ina_read_power</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This method well execute a read of the power.
If a callback was specified in ina_initialize, then
a callback frame is specified as follows:</p>
<p>[pin_type=0x11, device_i2c_address, read_type=4 (power), power, units='mW', timestamp]</p>
<p>The data is also saved to be retrieved by ina_read_power_last()</p>
<p>:return: callback is called and storage updated with latest value</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ina_read_power(self):
    &#34;&#34;&#34;
    This method well execute a read of the power.
    If a callback was specified in ina_initialize, then
    a callback frame is specified as follows:

    [pin_type=0x11, device_i2c_address, read_type=4 (power), power, units=&#39;mW&#39;, timestamp]

    The data is also saved to be retrieved by ina_read_power_last()

    :return: callback is called and storage updated with latest value
    &#34;&#34;&#34;
    # noinspection PyProtectedMember
    self.ina219.power()</code></pre>
</details>
</dd>
<dt id="pymata_rh.pymata_rh.PymataRh.ina_read_power_last"><code class="name flex">
<span>def <span class="ident">ina_read_power_last</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This method retrieves the last read power value.</p>
<p>:return: list:
[pin_type=0x11, device_i2c_address, read_type=4 (power), power, units='mW', timestamp]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ina_read_power_last(self):
    &#34;&#34;&#34;
    This method retrieves the last read power value.

    :return: list:
            [pin_type=0x11, device_i2c_address, read_type=4 (power), power, units=&#39;mW&#39;, timestamp]

    &#34;&#34;&#34;

    # noinspection PyProtectedMember
    return self.ina_last_value_power</code></pre>
</details>
</dd>
<dt id="pymata_rh.pymata_rh.PymataRh.ina_read_shunt_voltage"><code class="name flex">
<span>def <span class="ident">ina_read_shunt_voltage</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This method well execute a read of the shunt voltage.
If a callback was specified in ina_initialize, then
a callback frame is specified as follows:</p>
<p>[pin_type=0x11, device_i2c_address, read_type=3 (supply voltage), shunt voltage, units='mV', timestamp]</p>
<p>The data is also saved to be retrieved by ina_read_shunt_voltage_last()</p>
<p>:return: callback is called and storage updated with latest value</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ina_read_shunt_voltage(self):
    &#34;&#34;&#34;
    This method well execute a read of the shunt voltage.
    If a callback was specified in ina_initialize, then
    a callback frame is specified as follows:

    [pin_type=0x11, device_i2c_address, read_type=3 (supply voltage), shunt voltage, units=&#39;mV&#39;, timestamp]

    The data is also saved to be retrieved by ina_read_shunt_voltage_last()

    :return: callback is called and storage updated with latest value
    &#34;&#34;&#34;
    # noinspection PyProtectedMember
    self.ina219.shunt_voltage()</code></pre>
</details>
</dd>
<dt id="pymata_rh.pymata_rh.PymataRh.ina_read_shunt_voltage_last"><code class="name flex">
<span>def <span class="ident">ina_read_shunt_voltage_last</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This method well execute a read of the shunt voltage.
If a callback was specified in ina_initialize, then
a callback frame is specified as follows:</p>
<p>:return: list:
[pin_type=0x11, device_i2c_address, read_type=3 (shunt voltage), shunt voltage, units='mV', timestamp]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ina_read_shunt_voltage_last(self):
    &#34;&#34;&#34;
    This method well execute a read of the shunt voltage.
    If a callback was specified in ina_initialize, then
    a callback frame is specified as follows:


    :return: list:
    [pin_type=0x11, device_i2c_address, read_type=3 (shunt voltage), shunt voltage, units=&#39;mV&#39;, timestamp]
    &#34;&#34;&#34;

    # noinspection PyProtectedMember
    return self.ina_last_value_shunt_voltage</code></pre>
</details>
</dd>
<dt id="pymata_rh.pymata_rh.PymataRh.ina_read_supply_voltage"><code class="name flex">
<span>def <span class="ident">ina_read_supply_voltage</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This method well execute a read of the supply voltage.
If a callback was specified in ina_initialize, then
a callback frame is specified as follows:</p>
<p>[pin_type=0x11, device_i2c_address, read_type=2 (supply voltage), supply voltage, unit='V',timestamp]</p>
<p>The data is also saved to be retrieved by ina_read_supply_voltage_last()</p>
<p>:return: callback is called and storage updated with latest value</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ina_read_supply_voltage(self):
    &#34;&#34;&#34;
    This method well execute a read of the supply voltage.
    If a callback was specified in ina_initialize, then
    a callback frame is specified as follows:

    [pin_type=0x11, device_i2c_address, read_type=2 (supply voltage), supply voltage, unit=&#39;V&#39;,timestamp]

    The data is also saved to be retrieved by ina_read_supply_voltage_last()

    :return: callback is called and storage updated with latest value
    &#34;&#34;&#34;
    # noinspection PyProtectedMember
    self.ina219.supply_voltage()</code></pre>
</details>
</dd>
<dt id="pymata_rh.pymata_rh.PymataRh.ina_read_supply_voltage_last"><code class="name flex">
<span>def <span class="ident">ina_read_supply_voltage_last</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This method retrieves the last supply voltage read.</p>
<p>:return: list:</p>
<p>[pin_type=0x11, device_i2c_address, read_type=2 (supply voltage), voltage, units='V', timestamp]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ina_read_supply_voltage_last(self):
    &#34;&#34;&#34;
    This method retrieves the last supply voltage read.

    :return: list:

    [pin_type=0x11, device_i2c_address, read_type=2 (supply voltage), voltage, units=&#39;V&#39;, timestamp]

    &#34;&#34;&#34;
    return self.ina_last_value_supply_voltage</code></pre>
</details>
</dd>
<dt id="pymata_rh.pymata_rh.PymataRh.ina_sleep"><code class="name flex">
<span>def <span class="ident">ina_sleep</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ina_sleep(self):
    self.ina219.ina_sleep()</code></pre>
</details>
</dd>
<dt id="pymata_rh.pymata_rh.PymataRh.ina_wake"><code class="name flex">
<span>def <span class="ident">ina_wake</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ina_wake(self):
    self.ina219.ina_wake()</code></pre>
</details>
</dd>
<dt id="pymata_rh.pymata_rh.PymataRh.mpu_9250_calibrate"><code class="name flex">
<span>def <span class="ident">mpu_9250_calibrate</span></span>(<span>self, log=True)</span>
</code></dt>
<dd>
<div class="desc"><p>This method will calibrate the device. This is a lengthy process
and may take about a minute to complete.</p>
<p>This method will:
1. Test if the mpu_9250 was initialized and if not, it will
initialize with the default values.
2. Print the current device settings.
3. Run the calibrations for both the calibrate_ak8963 and MPU6050.
4. Configure the device with the new settings.
5. Print the new device settings.</p>
<p>:param: logging - If set to true calibration data is logged to a file
named mpu_calibration.log</p>
<p>:return: If an error is encountered a RunTimeError exception is raised.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mpu_9250_calibrate(self, log=True):
    &#34;&#34;&#34;
    This method will calibrate the device. This is a lengthy process
    and may take about a minute to complete.

    This method will:
    1. Test if the mpu_9250 was initialized and if not, it will
       initialize with the default values.
    2. Print the current device settings.
    3. Run the calibrations for both the calibrate_ak8963 and MPU6050.
    4. Configure the device with the new settings.
    5. Print the new device settings.

    :param: logging - If set to true calibration data is logged to a file
                      named mpu_calibration.log

    :return: If an error is encountered a RunTimeError exception is raised.
    &#34;&#34;&#34;
    if logging:
        logging.basicConfig(filename=&#39;mpu_calibration.log&#39;, filemode=&#39;a&#39;, level=logging.DEBUG)
        print(&#39;Configuration data being logged to mpu_calibration.log&#39;)

    if not self.mpu_9250_device:
        print(&#39;Initializing mpu9250&#39;)
        self.mpu_9250_initialize()
    print(&#39;Settings Before Calibration:&#39;)
    if log:
        logging.info(&#39;&#39;)
        logging.info(f&#39;Calibration Date: {datetime.datetime.now()}&#39;)
        logging.info(&#39;Settings Before Calibration:&#39;)

    print()
    if log:
        self._mpu_9250_get_current_settings(log=True)
    else:
        self._mpu_9250_get_current_settings(log=False)
    print()
    print(&#39;Calibrating ...&#39;)
    print()
    self.mpu_9250_device.calibrate()

    print(&#39;Configuring with calibrated values...&#39;)
    print()
    self.mpu_9250_device.configure()
    print()

    print(&#39;Settings After Calibration:&#39;)
    if log:
        logging.info(&#39;Settings After Calibration:&#39;)
    print()
    if log:
        self._mpu_9250_get_current_settings(log=True)
    else:
        self._mpu_9250_get_current_settings(log=False)

    print()</code></pre>
</details>
</dd>
<dt id="pymata_rh.pymata_rh.PymataRh.mpu_9250_initialize"><code class="name flex">
<span>def <span class="ident">mpu_9250_initialize</span></span>(<span>self, address_ak=12, address_mpu=105, g_fs=1, a_fs=0, m_fs=1, mode=2, a_bias=(0, 0, 0), g_bias=(0, 0, 0), m_bias=(0, 0, 0), mag_scale=(1, 1, 1), callback=None)</span>
</code></dt>
<dd>
<div class="desc"><p>This method instantiates an mpu_9250 object.
It also creates the thread to manage the mpu_9250 data retrieval.</p>
<p>:param address_ak: AK8963 I2C address (default:AK8963_ADDRESS[0x0C]).</p>
<p>:param address_mpu:
MPU-9250 I2C address (default:MPU9050_ADDRESS_68[0x68]).</p>
<p>:param g_fs: Gyroscope full scale select (default:GFS_2000[2000dps]).</p>
<p>:param a_fs: Accelerometer full scale select (default:AFS_16G[16g]).</p>
<p>:param m_fs: Magnetometer scale select (default:AK8963_BIT_16[16bit])</p>
<p>:param mode: Magnetometer mode select (default:AK8963_MODE_C8HZ)</p>
<p>:param a_bias: Accelerometer Bias</p>
<p>:param g_bias: Gyroscope Bias</p>
<p>:param m_bias: Magnetometer Hard Iron Distortion</p>
<p>:param mag_scale: Magnetometer Soft Iron Distortion</p>
<p>:param callback: Callback method that will receive mpu data frames</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mpu_9250_initialize(self, address_ak=mpu_constants.AK8963_ADDRESS,
                        address_mpu=mpu_constants.MPU9250_ADDRESS_69,
                        g_fs=mpu_constants.GFS_500,
                        a_fs=mpu_constants.AFS_2G,
                        m_fs=mpu_constants.AK8963_BIT_16,
                        mode=mpu_constants.AK8963_MODE_C8HZ,
                        a_bias=(0, 0, 0), g_bias=(0, 0, 0),
                        m_bias=(0, 0, 0),
                        mag_scale=(1, 1, 1),
                        callback=None
                        ):
    &#34;&#34;&#34;
    This method instantiates an mpu_9250 object.
    It also creates the thread to manage the mpu_9250 data retrieval.

    :param address_ak: AK8963 I2C address (default:AK8963_ADDRESS[0x0C]).

    :param address_mpu:  MPU-9250 I2C address (default:MPU9050_ADDRESS_68[0x68]).

    :param g_fs: Gyroscope full scale select (default:GFS_2000[2000dps]).

    :param a_fs: Accelerometer full scale select (default:AFS_16G[16g]).

    :param m_fs: Magnetometer scale select (default:AK8963_BIT_16[16bit])

    :param mode: Magnetometer mode select (default:AK8963_MODE_C8HZ)

    :param a_bias: Accelerometer Bias

    :param g_bias: Gyroscope Bias

    :param m_bias: Magnetometer Hard Iron Distortion

    :param mag_scale: Magnetometer Soft Iron Distortion

    :param callback: Callback method that will receive mpu data frames

    &#34;&#34;&#34;
    self.mpu_callback = callback

    # make sure that we initialize i2c mode
    self.set_pin_mode_i2c()

    self.mpu_9250_device = MPU9250(self, address_ak, address_mpu,
                                   g_fs, a_fs, m_fs, mode,
                                   mag_scale=mag_scale, g_bias=g_bias,
                                   a_bias=a_bias, m_bias=m_bias)
    self.mpu_callback = callback</code></pre>
</details>
</dd>
<dt id="pymata_rh.pymata_rh.PymataRh.mpu_9250_read_data"><code class="name flex">
<span>def <span class="ident">mpu_9250_read_data</span></span>(<span>self, mode=1, continuous_delay=0.3)</span>
</code></dt>
<dd>
<div class="desc"><p>Read and report mpu_9250 data for accelerometer, gyroscope,
magnetometer, and device temperature.</p>
<p>:param mode: MPU9250_READ_CONTINUOUS_ON(0) - data is read continuously, or
MPU9250_READ_CONTINUOUS_OFF - turn off continuous reads.</p>
<p>:param continuous_delay: Delay between reads</p>
<p>:return: For MPU9250_READ_CONTINUOUS_ON, if a callback was specified in
mpu_9250_initialize(), then data returned is returned via callback.</p>
<pre><code>     Callback data is a list with format:
     index[0] = pin type - for mpu9250 the value is 16
     index[1] = mpu address
     index[2] = accelerometer x axis
     index[3] = accelerometer y axis
     index[4] = accelerometer z axis
     index[5] = gyroscope x axis
     index[6] = gyroscope y axis
     index[7] = gyroscope z axis
     index[8] = magnetometer x axis
     index[9] = magnetometer y axis
     index[10] = magnetometer z axis
     index[11] = temperature
     index[12] = timestamp

     If no callback was specified, then data is stored and can be
     retrieved using mpu_9250_read_saved_data().
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mpu_9250_read_data(self, mode=mpu_constants.MPU9250_READ_CONTINUOUS_ON,
                       continuous_delay=0.3):
    &#34;&#34;&#34;
    Read and report mpu_9250 data for accelerometer, gyroscope,
    magnetometer, and device temperature.

    :param mode: MPU9250_READ_CONTINUOUS_ON(0) - data is read continuously, or
                 MPU9250_READ_CONTINUOUS_OFF - turn off continuous reads.

    :param continuous_delay: Delay between reads

    :return: For MPU9250_READ_CONTINUOUS_ON, if a callback was specified in
    mpu_9250_initialize(), then data returned is returned via callback.

             Callback data is a list with format:
             index[0] = pin type - for mpu9250 the value is 16
             index[1] = mpu address
             index[2] = accelerometer x axis
             index[3] = accelerometer y axis
             index[4] = accelerometer z axis
             index[5] = gyroscope x axis
             index[6] = gyroscope y axis
             index[7] = gyroscope z axis
             index[8] = magnetometer x axis
             index[9] = magnetometer y axis
             index[10] = magnetometer z axis
             index[11] = temperature
             index[12] = timestamp

             If no callback was specified, then data is stored and can be
             retrieved using mpu_9250_read_saved_data().
    &#34;&#34;&#34;
    self.mpu_read_delay = continuous_delay
    if mode == mpu_constants.MPU9250_READ_CONTINUOUS_ON:
        self._mpu9250_thread_run()
    elif mode == mpu_constants.MPU9250_READ_CONTINUOUS_OFF:
        self._mpu9250_thread_stop()
    else:
        raise RuntimeError(f&#39;Unknown mode passed to mpu_9250_read_data(). mode == {mode}&#39;)</code></pre>
</details>
</dd>
<dt id="pymata_rh.pymata_rh.PymataRh.mpu_9250_read_saved_data"><code class="name flex">
<span>def <span class="ident">mpu_9250_read_saved_data</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve and return the last data set read from the mpu_9250</p>
<p>:return: last read data in list form or [] if no data is available.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mpu_9250_read_saved_data(self):
    &#34;&#34;&#34;
    Retrieve and return the last data set read from the mpu_9250

    :return: last read data in list form or [] if no data is available.
    &#34;&#34;&#34;
    if self.mpu_9250_device.address_mpu:
        return self.mpu_last_value</code></pre>
</details>
</dd>
<dt id="pymata_rh.pymata_rh.PymataRh.pwm_write"><code class="name flex">
<span>def <span class="ident">pwm_write</span></span>(<span>self, pin, value)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the selected pwm pin to the specified value.</p>
<p>:param pin: PWM pin number</p>
<p>:param value: Pin value (0 - 0x4000)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pwm_write(self, pin, value):
    &#34;&#34;&#34;
    Set the selected pwm pin to the specified value.

    :param pin: PWM pin number

    :param value: Pin value (0 - 0x4000)

    &#34;&#34;&#34;
    if PrivateConstants.PWM_MESSAGE + pin &lt; 0xf0:
        command = [PrivateConstants.PWM_MESSAGE + pin, value &amp; 0x7f,
                   (value &gt;&gt; 7) &amp; 0x7f]
        self._send_command(command)
    else:
        self._pwm_write_extended(pin, value)</code></pre>
</details>
</dd>
<dt id="pymata_rh.pymata_rh.PymataRh.send_reset"><code class="name flex">
<span>def <span class="ident">send_reset</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Send a Sysex reset command to the arduino</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_reset(self):
    &#34;&#34;&#34;
    Send a Sysex reset command to the arduino

    &#34;&#34;&#34;
    try:
        self._send_command([PrivateConstants.SYSTEM_RESET])
    except RuntimeError:
        raise</code></pre>
</details>
</dd>
<dt id="pymata_rh.pymata_rh.PymataRh.servo_write"><code class="name flex">
<span>def <span class="ident">servo_write</span></span>(<span>self, pin, position)</span>
</code></dt>
<dd>
<div class="desc"><p>This is an alias for analog_write to set
the position of a servo that has been
previously configured using set_pin_mode_servo.</p>
<p>:param pin: arduino pin number</p>
<p>:param position: servo position</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def servo_write(self, pin, position):
    &#34;&#34;&#34;
    This is an alias for analog_write to set
    the position of a servo that has been
    previously configured using set_pin_mode_servo.

    :param pin: arduino pin number

    :param position: servo position

    &#34;&#34;&#34;

    self.pwm_write(pin, position)</code></pre>
</details>
</dd>
<dt id="pymata_rh.pymata_rh.PymataRh.set_pin_mode_analog_input"><code class="name flex">
<span>def <span class="ident">set_pin_mode_analog_input</span></span>(<span>self, pin_number, callback=None, differential=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Set a pin as an analog input.</p>
<p>:param pin_number: arduino pin number</p>
<p>:param callback: callback function</p>
<p>:param differential: This value needs to be met for a callback
to be invoked.</p>
<p>callback returns a data list:</p>
<p>[pin_type, pin_number, pin_value, raw_time_stamp]</p>
<p>The pin_type for analog input pins = 2</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_pin_mode_analog_input(self, pin_number, callback=None,
                              differential=1):
    &#34;&#34;&#34;
    Set a pin as an analog input.

    :param pin_number: arduino pin number

    :param callback: callback function

    :param differential: This value needs to be met for a callback
                         to be invoked.


    callback returns a data list:

    [pin_type, pin_number, pin_value, raw_time_stamp]

    The pin_type for analog input pins = 2

    &#34;&#34;&#34;
    self._set_pin_mode(pin_number, PrivateConstants.ANALOG,
                       callback=callback,
                       differential=differential)</code></pre>
</details>
</dd>
<dt id="pymata_rh.pymata_rh.PymataRh.set_pin_mode_dht"><code class="name flex">
<span>def <span class="ident">set_pin_mode_dht</span></span>(<span>self, pin_number, sensor_type=22, differential=0.1, callback=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Configure a DHT sensor prior to operation.
Up to 6 DHT sensors are supported</p>
<p>:param pin_number: digital pin number on arduino.</p>
<p>:param sensor_type: type of dht sensor
Valid values = DHT11, DHT12, DHT22, DHT21, AM2301</p>
<p>:param differential: This value needs to be met for a callback
to be invoked.</p>
<p>:param callback: callback function</p>
<p>callback: returns a data list:</p>
<p>[pin_type, pin_number, DHT type, humidity value, temperature raw_time_stamp]</p>
<p>The pin_type for DHT input pins = 15</p>
<pre><code>    ERROR CODES: If either humidity or temperature value:
                  == -1 Configuration Error
                  == -2 Checksum Error
                  == -3 Timeout Error
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_pin_mode_dht(self, pin_number, sensor_type=22, differential=.1, callback=None):
    &#34;&#34;&#34;
    Configure a DHT sensor prior to operation.
    Up to 6 DHT sensors are supported

    :param pin_number: digital pin number on arduino.

    :param sensor_type: type of dht sensor
                        Valid values = DHT11, DHT12, DHT22, DHT21, AM2301

    :param differential: This value needs to be met for a callback
                         to be invoked.

    :param callback: callback function

    callback: returns a data list:

    [pin_type, pin_number, DHT type, humidity value, temperature raw_time_stamp]

    The pin_type for DHT input pins = 15

            ERROR CODES: If either humidity or temperature value:
                          == -1 Configuration Error
                          == -2 Checksum Error
                          == -3 Timeout Error
    &#34;&#34;&#34;

    # if the pin is not currently associated with a DHT device
    # initialize it.
    if pin_number not in self.dht_list:
        self.dht_list.append(pin_number)
        self.digital_pins[pin_number].cb = callback
        self.digital_pins[pin_number].current_value = [0, 0]
        self.digital_pins[pin_number].differential = differential
        data = [pin_number, sensor_type]
        self._send_sysex(PrivateConstants.DHT_CONFIG, data)
    else:
        # allow user to change the differential value
        self.digital_pins[pin_number].differential = differential</code></pre>
</details>
</dd>
<dt id="pymata_rh.pymata_rh.PymataRh.set_pin_mode_digital_input"><code class="name flex">
<span>def <span class="ident">set_pin_mode_digital_input</span></span>(<span>self, pin_number, callback=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Set a pin as a digital input.</p>
<p>:param pin_number: arduino pin number</p>
<p>:param callback: callback function</p>
<p>callback returns a data list:</p>
<p>[pin_type, pin_number, pin_value, raw_time_stamp]</p>
<p>The pin_type for digital input pins = 0</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_pin_mode_digital_input(self, pin_number, callback=None):
    &#34;&#34;&#34;
    Set a pin as a digital input.

    :param pin_number: arduino pin number

    :param callback: callback function


    callback returns a data list:

    [pin_type, pin_number, pin_value, raw_time_stamp]

    The pin_type for digital input pins = 0

    &#34;&#34;&#34;
    self._set_pin_mode(pin_number, PrivateConstants.INPUT, callback)</code></pre>
</details>
</dd>
<dt id="pymata_rh.pymata_rh.PymataRh.set_pin_mode_digital_input_pullup"><code class="name flex">
<span>def <span class="ident">set_pin_mode_digital_input_pullup</span></span>(<span>self, pin_number, callback=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Set a pin as a digital input with pullup enabled.</p>
<p>:param pin_number: arduino pin number</p>
<p>:param callback: callback function</p>
<p>callback returns a data list:</p>
<p>[pin_type, pin_number, pin_value, raw_time_stamp]</p>
<p>The pin_type for digital input pins with pullups enabled = 11</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_pin_mode_digital_input_pullup(self, pin_number, callback=None):
    &#34;&#34;&#34;
    Set a pin as a digital input with pullup enabled.

    :param pin_number: arduino pin number

    :param callback: callback function


    callback returns a data list:

    [pin_type, pin_number, pin_value, raw_time_stamp]

    The pin_type for digital input pins with pullups enabled = 11

    &#34;&#34;&#34;
    self._set_pin_mode(pin_number, PrivateConstants.PULLUP, callback)</code></pre>
</details>
</dd>
<dt id="pymata_rh.pymata_rh.PymataRh.set_pin_mode_digital_output"><code class="name flex">
<span>def <span class="ident">set_pin_mode_digital_output</span></span>(<span>self, pin_number)</span>
</code></dt>
<dd>
<div class="desc"><p>Set a pin as a digital output pin.</p>
<p>:param pin_number: arduino pin number</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_pin_mode_digital_output(self, pin_number):
    &#34;&#34;&#34;
    Set a pin as a digital output pin.

    :param pin_number: arduino pin number
    &#34;&#34;&#34;

    self._set_pin_mode(pin_number, PrivateConstants.OUTPUT)</code></pre>
</details>
</dd>
<dt id="pymata_rh.pymata_rh.PymataRh.set_pin_mode_i2c"><code class="name flex">
<span>def <span class="ident">set_pin_mode_i2c</span></span>(<span>self, read_delay_time=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Establish the standard Arduino i2c pins for i2c utilization.</p>
<p>NOTE: THIS METHOD MUST BE CALLED BEFORE ANY I2C REQUEST IS MADE
This method initializes Firmata for I2c operations.</p>
<p>:param read_delay_time (in microseconds): an optional parameter,
default is 0</p>
<p>NOTE: Callbacks are set within the individual i2c read methods of this
API.
See i2c_read, i2c_read_continuous, or i2c_read_restart_transmission.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_pin_mode_i2c(self, read_delay_time=0):
    &#34;&#34;&#34;
    Establish the standard Arduino i2c pins for i2c utilization.

    NOTE: THIS METHOD MUST BE CALLED BEFORE ANY I2C REQUEST IS MADE
    This method initializes Firmata for I2c operations.

    :param read_delay_time (in microseconds): an optional parameter,
                                              default is 0

    NOTE: Callbacks are set within the individual i2c read methods of this
          API.
          See i2c_read, i2c_read_continuous, or i2c_read_restart_transmission.

    &#34;&#34;&#34;
    if not self.i2c_configured:
        data = [read_delay_time &amp; 0x7f, (read_delay_time &gt;&gt; 7) &amp; 0x7f]
        self._send_sysex(PrivateConstants.I2C_CONFIG, data)
        self.i2c_configured = True</code></pre>
</details>
</dd>
<dt id="pymata_rh.pymata_rh.PymataRh.set_pin_mode_pwm_output"><code class="name flex">
<span>def <span class="ident">set_pin_mode_pwm_output</span></span>(<span>self, pin_number)</span>
</code></dt>
<dd>
<div class="desc"><p>Set a pin as a pwm (analog output) pin.</p>
<p>:param pin_number:arduino pin number</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_pin_mode_pwm_output(self, pin_number):
    &#34;&#34;&#34;
    Set a pin as a pwm (analog output) pin.

    :param pin_number:arduino pin number

    &#34;&#34;&#34;
    self._set_pin_mode(pin_number, PrivateConstants.PWM)</code></pre>
</details>
</dd>
<dt id="pymata_rh.pymata_rh.PymataRh.set_pin_mode_servo"><code class="name flex">
<span>def <span class="ident">set_pin_mode_servo</span></span>(<span>self, pin, min_pulse=544, max_pulse=2400)</span>
</code></dt>
<dd>
<div class="desc"><p>Configure a pin as a servo pin. Set pulse min, max in ms.</p>
<p>:param pin: Servo Pin.</p>
<p>:param min_pulse: Min pulse width in ms.</p>
<p>:param max_pulse: Max pulse width in ms.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_pin_mode_servo(self, pin, min_pulse=544, max_pulse=2400):
    &#34;&#34;&#34;
    Configure a pin as a servo pin. Set pulse min, max in ms.

    :param pin: Servo Pin.

    :param min_pulse: Min pulse width in ms.

    :param max_pulse: Max pulse width in ms.

    &#34;&#34;&#34;
    command = [pin, min_pulse &amp; 0x7f, (min_pulse &gt;&gt; 7) &amp; 0x7f,
               max_pulse &amp; 0x7f,
               (max_pulse &gt;&gt; 7) &amp; 0x7f]

    self._send_sysex(PrivateConstants.SERVO_CONFIG, command)</code></pre>
</details>
</dd>
<dt id="pymata_rh.pymata_rh.PymataRh.set_pin_mode_sonar"><code class="name flex">
<span>def <span class="ident">set_pin_mode_sonar</span></span>(<span>self, trigger_pin, echo_pin, callback=None, timeout=80000)</span>
</code></dt>
<dd>
<div class="desc"><p>This is a FirmataExpress feature.</p>
<p>Configure the pins,ping interval and maximum distance for an HC-SR04
type device.</p>
<p>Up to a maximum of 6 SONAR devices is supported.
If the maximum is exceeded a message is sent to the console and the
request is ignored.</p>
<p>NOTE: data is measured in centimeters. Callback is called only when the
the latest value received is different than the previous.</p>
<p>:param trigger_pin: The pin number of for the trigger (transmitter).</p>
<p>:param echo_pin: The pin number for the received echo.</p>
<p>:param callback: optional callback function to report sonar data changes</p>
<p>:param timeout: a tuning parameter. 80000UL equals 80ms.</p>
<p>callback returns a data list:</p>
<p>[pin_type, trigger_pin_number, distance_value (in cm), raw_time_stamp]</p>
<p>The pin_type for sonar pins = 12</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_pin_mode_sonar(self, trigger_pin, echo_pin,
                       callback=None, timeout=80000):
    &#34;&#34;&#34;
    This is a FirmataExpress feature.

    Configure the pins,ping interval and maximum distance for an HC-SR04
    type device.

    Up to a maximum of 6 SONAR devices is supported.
    If the maximum is exceeded a message is sent to the console and the
    request is ignored.

    NOTE: data is measured in centimeters. Callback is called only when the
          the latest value received is different than the previous.

    :param trigger_pin: The pin number of for the trigger (transmitter).

    :param echo_pin: The pin number for the received echo.

    :param callback: optional callback function to report sonar data changes

    :param timeout: a tuning parameter. 80000UL equals 80ms.


    callback returns a data list:

    [pin_type, trigger_pin_number, distance_value (in cm), raw_time_stamp]

    The pin_type for sonar pins = 12


    &#34;&#34;&#34;
    # if there is an entry for the trigger pin in existence,
    # ignore the duplicate request.
    if trigger_pin in self.active_sonar_map:
        return

    timeout_lsb = timeout &amp; 0x7f
    timeout_msb = (timeout &gt;&gt; 7) &amp; 0x7f
    data = [trigger_pin, echo_pin, timeout_lsb,
            timeout_msb]

    self._set_pin_mode(trigger_pin, PrivateConstants.SONAR,
                       PrivateConstants.INPUT)
    self._set_pin_mode(echo_pin, PrivateConstants.SONAR,
                       PrivateConstants.INPUT)
    # update the ping data map for this pin
    if len(self.active_sonar_map) &gt; 6:
        print(&#39;sonar_config: maximum number of devices assigned&#39;
              &#39; - ignoring request&#39;)
    else:
        # initialize map entry with callback, data value of 0 and time_stamp of 0
        self.active_sonar_map[trigger_pin] = [callback, 0, 0]

    self._send_sysex(PrivateConstants.SONAR_CONFIG, data)</code></pre>
</details>
</dd>
<dt id="pymata_rh.pymata_rh.PymataRh.set_sampling_interval"><code class="name flex">
<span>def <span class="ident">set_sampling_interval</span></span>(<span>self, interval)</span>
</code></dt>
<dd>
<div class="desc"><p>This method sends the desired sampling interval to Firmata.</p>
<p>Note: Standard Firmata
will ignore any interval less than
10 milliseconds</p>
<p>:param interval: Integer value for desired sampling interval
in milliseconds</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_sampling_interval(self, interval):
    &#34;&#34;&#34;
    This method sends the desired sampling interval to Firmata.

    Note: Standard Firmata  will ignore any interval less than
          10 milliseconds

    :param interval: Integer value for desired sampling interval
                     in milliseconds

    &#34;&#34;&#34;
    data = [interval &amp; 0x7f, (interval &gt;&gt; 7) &amp; 0x7f]
    self._send_sysex(PrivateConstants.SAMPLING_INTERVAL, data)</code></pre>
</details>
</dd>
<dt id="pymata_rh.pymata_rh.PymataRh.shutdown"><code class="name flex">
<span>def <span class="ident">shutdown</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This method attempts an orderly shutdown
If any exceptions are thrown, they are ignored.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def shutdown(self):
    &#34;&#34;&#34;
    This method attempts an orderly shutdown
    If any exceptions are thrown, they are ignored.

    &#34;&#34;&#34;

    self.shutdown_flag = True

    self._stop_threads()

    try:
        # stop all reporting - both analog and digital
        for pin in range(len(self.analog_pins)):
            self.disable_analog_reporting(pin)

        for pin in range(len(self.digital_pins)):
            self.disable_digital_reporting(pin)
        self.send_reset()
        if self.ip_address:
            try:
                self.sock.shutdown(socket.SHUT_RDWR)
                self.sock.close()
            except Exception:
                pass
        else:
            self.serial_port.reset_input_buffer()
            self.serial_port.close()

    except (RuntimeError, SerialException, OSError):
        # ignore error on shutdown
        pass</code></pre>
</details>
</dd>
<dt id="pymata_rh.pymata_rh.PymataRh.sonar_read"><code class="name flex">
<span>def <span class="ident">sonar_read</span></span>(<span>self, trigger_pin)</span>
</code></dt>
<dd>
<div class="desc"><p>This is a FirmataExpress feature</p>
<p>Retrieve Ping (HC-SR04 type) data. The data is presented as a
dictionary.</p>
<p>The 'key' is the trigger pin specified in sonar_config()
and the 'data' is the current measured distance (in centimeters)
for that pin. If there is no data, the value is set to None.</p>
<p>:param trigger_pin: key into sonar data map</p>
<p>:returns: A list = [last value, raw time_stamp]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sonar_read(self, trigger_pin):
    &#34;&#34;&#34;
    This is a FirmataExpress feature

    Retrieve Ping (HC-SR04 type) data. The data is presented as a
    dictionary.

    The &#39;key&#39; is the trigger pin specified in sonar_config()
    and the &#39;data&#39; is the current measured distance (in centimeters)
    for that pin. If there is no data, the value is set to None.

    :param trigger_pin: key into sonar data map

    :returns: A list = [last value, raw time_stamp]

    &#34;&#34;&#34;

    sonar_pin_entry = self.active_sonar_map.get(trigger_pin)
    if sonar_pin_entry:
        return [sonar_pin_entry[1], sonar_pin_entry[2]]
    else:
        return [0, 0]</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pymata_rh" href="index.html">pymata_rh</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pymata_rh.pymata_rh.PymataRh" href="#pymata_rh.pymata_rh.PymataRh">PymataRh</a></code></h4>
<ul class="">
<li><code><a title="pymata_rh.pymata_rh.PymataRh.analog_read" href="#pymata_rh.pymata_rh.PymataRh.analog_read">analog_read</a></code></li>
<li><code><a title="pymata_rh.pymata_rh.PymataRh.dht_read" href="#pymata_rh.pymata_rh.PymataRh.dht_read">dht_read</a></code></li>
<li><code><a title="pymata_rh.pymata_rh.PymataRh.digital_read" href="#pymata_rh.pymata_rh.PymataRh.digital_read">digital_read</a></code></li>
<li><code><a title="pymata_rh.pymata_rh.PymataRh.digital_write" href="#pymata_rh.pymata_rh.PymataRh.digital_write">digital_write</a></code></li>
<li><code><a title="pymata_rh.pymata_rh.PymataRh.disable_analog_reporting" href="#pymata_rh.pymata_rh.PymataRh.disable_analog_reporting">disable_analog_reporting</a></code></li>
<li><code><a title="pymata_rh.pymata_rh.PymataRh.disable_digital_reporting" href="#pymata_rh.pymata_rh.PymataRh.disable_digital_reporting">disable_digital_reporting</a></code></li>
<li><code><a title="pymata_rh.pymata_rh.PymataRh.enable_analog_reporting" href="#pymata_rh.pymata_rh.PymataRh.enable_analog_reporting">enable_analog_reporting</a></code></li>
<li><code><a title="pymata_rh.pymata_rh.PymataRh.enable_digital_reporting" href="#pymata_rh.pymata_rh.PymataRh.enable_digital_reporting">enable_digital_reporting</a></code></li>
<li><code><a title="pymata_rh.pymata_rh.PymataRh.get_analog_map" href="#pymata_rh.pymata_rh.PymataRh.get_analog_map">get_analog_map</a></code></li>
<li><code><a title="pymata_rh.pymata_rh.PymataRh.get_capability_report" href="#pymata_rh.pymata_rh.PymataRh.get_capability_report">get_capability_report</a></code></li>
<li><code><a title="pymata_rh.pymata_rh.PymataRh.get_firmware_version" href="#pymata_rh.pymata_rh.PymataRh.get_firmware_version">get_firmware_version</a></code></li>
<li><code><a title="pymata_rh.pymata_rh.PymataRh.get_pin_state" href="#pymata_rh.pymata_rh.PymataRh.get_pin_state">get_pin_state</a></code></li>
<li><code><a title="pymata_rh.pymata_rh.PymataRh.get_protocol_version" href="#pymata_rh.pymata_rh.PymataRh.get_protocol_version">get_protocol_version</a></code></li>
<li><code><a title="pymata_rh.pymata_rh.PymataRh.get_pymata_version" href="#pymata_rh.pymata_rh.PymataRh.get_pymata_version">get_pymata_version</a></code></li>
<li><code><a title="pymata_rh.pymata_rh.PymataRh.i2c_read" href="#pymata_rh.pymata_rh.PymataRh.i2c_read">i2c_read</a></code></li>
<li><code><a title="pymata_rh.pymata_rh.PymataRh.i2c_read_continuous" href="#pymata_rh.pymata_rh.PymataRh.i2c_read_continuous">i2c_read_continuous</a></code></li>
<li><code><a title="pymata_rh.pymata_rh.PymataRh.i2c_read_restart_transmission" href="#pymata_rh.pymata_rh.PymataRh.i2c_read_restart_transmission">i2c_read_restart_transmission</a></code></li>
<li><code><a title="pymata_rh.pymata_rh.PymataRh.i2c_read_saved_data" href="#pymata_rh.pymata_rh.PymataRh.i2c_read_saved_data">i2c_read_saved_data</a></code></li>
<li><code><a title="pymata_rh.pymata_rh.PymataRh.i2c_write" href="#pymata_rh.pymata_rh.PymataRh.i2c_write">i2c_write</a></code></li>
<li><code><a title="pymata_rh.pymata_rh.PymataRh.ina_initialize" href="#pymata_rh.pymata_rh.PymataRh.ina_initialize">ina_initialize</a></code></li>
<li><code><a title="pymata_rh.pymata_rh.PymataRh.ina_read_bus_current" href="#pymata_rh.pymata_rh.PymataRh.ina_read_bus_current">ina_read_bus_current</a></code></li>
<li><code><a title="pymata_rh.pymata_rh.PymataRh.ina_read_bus_current_last" href="#pymata_rh.pymata_rh.PymataRh.ina_read_bus_current_last">ina_read_bus_current_last</a></code></li>
<li><code><a title="pymata_rh.pymata_rh.PymataRh.ina_read_bus_voltage" href="#pymata_rh.pymata_rh.PymataRh.ina_read_bus_voltage">ina_read_bus_voltage</a></code></li>
<li><code><a title="pymata_rh.pymata_rh.PymataRh.ina_read_bus_voltage_last" href="#pymata_rh.pymata_rh.PymataRh.ina_read_bus_voltage_last">ina_read_bus_voltage_last</a></code></li>
<li><code><a title="pymata_rh.pymata_rh.PymataRh.ina_read_power" href="#pymata_rh.pymata_rh.PymataRh.ina_read_power">ina_read_power</a></code></li>
<li><code><a title="pymata_rh.pymata_rh.PymataRh.ina_read_power_last" href="#pymata_rh.pymata_rh.PymataRh.ina_read_power_last">ina_read_power_last</a></code></li>
<li><code><a title="pymata_rh.pymata_rh.PymataRh.ina_read_shunt_voltage" href="#pymata_rh.pymata_rh.PymataRh.ina_read_shunt_voltage">ina_read_shunt_voltage</a></code></li>
<li><code><a title="pymata_rh.pymata_rh.PymataRh.ina_read_shunt_voltage_last" href="#pymata_rh.pymata_rh.PymataRh.ina_read_shunt_voltage_last">ina_read_shunt_voltage_last</a></code></li>
<li><code><a title="pymata_rh.pymata_rh.PymataRh.ina_read_supply_voltage" href="#pymata_rh.pymata_rh.PymataRh.ina_read_supply_voltage">ina_read_supply_voltage</a></code></li>
<li><code><a title="pymata_rh.pymata_rh.PymataRh.ina_read_supply_voltage_last" href="#pymata_rh.pymata_rh.PymataRh.ina_read_supply_voltage_last">ina_read_supply_voltage_last</a></code></li>
<li><code><a title="pymata_rh.pymata_rh.PymataRh.ina_sleep" href="#pymata_rh.pymata_rh.PymataRh.ina_sleep">ina_sleep</a></code></li>
<li><code><a title="pymata_rh.pymata_rh.PymataRh.ina_wake" href="#pymata_rh.pymata_rh.PymataRh.ina_wake">ina_wake</a></code></li>
<li><code><a title="pymata_rh.pymata_rh.PymataRh.mpu_9250_calibrate" href="#pymata_rh.pymata_rh.PymataRh.mpu_9250_calibrate">mpu_9250_calibrate</a></code></li>
<li><code><a title="pymata_rh.pymata_rh.PymataRh.mpu_9250_initialize" href="#pymata_rh.pymata_rh.PymataRh.mpu_9250_initialize">mpu_9250_initialize</a></code></li>
<li><code><a title="pymata_rh.pymata_rh.PymataRh.mpu_9250_read_data" href="#pymata_rh.pymata_rh.PymataRh.mpu_9250_read_data">mpu_9250_read_data</a></code></li>
<li><code><a title="pymata_rh.pymata_rh.PymataRh.mpu_9250_read_saved_data" href="#pymata_rh.pymata_rh.PymataRh.mpu_9250_read_saved_data">mpu_9250_read_saved_data</a></code></li>
<li><code><a title="pymata_rh.pymata_rh.PymataRh.pwm_write" href="#pymata_rh.pymata_rh.PymataRh.pwm_write">pwm_write</a></code></li>
<li><code><a title="pymata_rh.pymata_rh.PymataRh.send_reset" href="#pymata_rh.pymata_rh.PymataRh.send_reset">send_reset</a></code></li>
<li><code><a title="pymata_rh.pymata_rh.PymataRh.servo_write" href="#pymata_rh.pymata_rh.PymataRh.servo_write">servo_write</a></code></li>
<li><code><a title="pymata_rh.pymata_rh.PymataRh.set_pin_mode_analog_input" href="#pymata_rh.pymata_rh.PymataRh.set_pin_mode_analog_input">set_pin_mode_analog_input</a></code></li>
<li><code><a title="pymata_rh.pymata_rh.PymataRh.set_pin_mode_dht" href="#pymata_rh.pymata_rh.PymataRh.set_pin_mode_dht">set_pin_mode_dht</a></code></li>
<li><code><a title="pymata_rh.pymata_rh.PymataRh.set_pin_mode_digital_input" href="#pymata_rh.pymata_rh.PymataRh.set_pin_mode_digital_input">set_pin_mode_digital_input</a></code></li>
<li><code><a title="pymata_rh.pymata_rh.PymataRh.set_pin_mode_digital_input_pullup" href="#pymata_rh.pymata_rh.PymataRh.set_pin_mode_digital_input_pullup">set_pin_mode_digital_input_pullup</a></code></li>
<li><code><a title="pymata_rh.pymata_rh.PymataRh.set_pin_mode_digital_output" href="#pymata_rh.pymata_rh.PymataRh.set_pin_mode_digital_output">set_pin_mode_digital_output</a></code></li>
<li><code><a title="pymata_rh.pymata_rh.PymataRh.set_pin_mode_i2c" href="#pymata_rh.pymata_rh.PymataRh.set_pin_mode_i2c">set_pin_mode_i2c</a></code></li>
<li><code><a title="pymata_rh.pymata_rh.PymataRh.set_pin_mode_pwm_output" href="#pymata_rh.pymata_rh.PymataRh.set_pin_mode_pwm_output">set_pin_mode_pwm_output</a></code></li>
<li><code><a title="pymata_rh.pymata_rh.PymataRh.set_pin_mode_servo" href="#pymata_rh.pymata_rh.PymataRh.set_pin_mode_servo">set_pin_mode_servo</a></code></li>
<li><code><a title="pymata_rh.pymata_rh.PymataRh.set_pin_mode_sonar" href="#pymata_rh.pymata_rh.PymataRh.set_pin_mode_sonar">set_pin_mode_sonar</a></code></li>
<li><code><a title="pymata_rh.pymata_rh.PymataRh.set_sampling_interval" href="#pymata_rh.pymata_rh.PymataRh.set_sampling_interval">set_sampling_interval</a></code></li>
<li><code><a title="pymata_rh.pymata_rh.PymataRh.shutdown" href="#pymata_rh.pymata_rh.PymataRh.shutdown">shutdown</a></code></li>
<li><code><a title="pymata_rh.pymata_rh.PymataRh.sonar_read" href="#pymata_rh.pymata_rh.PymataRh.sonar_read">sonar_read</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>